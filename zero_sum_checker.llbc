{"charon_version":"0.1.122","translated":{"crate_name":"zero_sum_checker","options":{"ullbc":false,"lib":false,"bin":null,"mir_promoted":false,"mir_optimized":false,"mir":null,"input_file":null,"read_llbc":null,"dest_dir":null,"dest_file":null,"use_polonius":false,"skip_borrowck":false,"monomorphize":false,"monomorphize_conservative":false,"extract_opaque_bodies":false,"translate_all_methods":false,"include":[],"opaque":[],"exclude":["core::ops::drop::Drop","{impl core::ops::drop::Drop for _}"],"remove_associated_types":["*"],"hide_marker_traits":true,"hide_allocator":true,"remove_unused_self_clauses":true,"add_drop_bounds":false,"start_from":[],"no_cargo":false,"rustc_args":[],"cargo_args":[],"abort_on_error":false,"error_on_warnings":false,"no_serialize":false,"print_original_ullbc":false,"print_ullbc":false,"print_built_llbc":false,"print_llbc":false,"no_merge_goto_chains":false,"no_ops_to_function_calls":false,"raw_boxes":false,"preset":"Aeneas"},"target_information":{"target_pointer_size":8,"is_little_endian":true},"item_names":[{"key":{"Fun":1},"value":[{"Ident":["zero_sum_checker",0]},{"Ident":["has_zero_sum_pair_brute_force",0]}]},{"key":{"Fun":29},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]},{"Ident":["clone",0]}]},{"key":{"Fun":100},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["try_find",0]}]},{"key":{"Fun":121},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["eq",0]}]},{"key":{"Fun":146},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["try_rfold",0]}]},{"key":{"Fun":43},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["last",0]}]},{"key":{"Fun":97},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["any",0]}]},{"key":{"Fun":180},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["lt",0]}]},{"key":{"TraitDecl":25},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["exact_size",0]},{"Ident":["ExactSizeIterator",0]}]},{"key":{"TraitDecl":18},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnOnce",0]}]},{"key":{"Fun":111},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["copied",0]}]},{"key":{"Fun":78},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["scan",0]}]},{"key":{"Fun":42},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["count",0]}]},{"key":{"Fun":44},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["advance_by",0]}]},{"key":{"TraitDecl":15},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]}]},{"key":{"Fun":92},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["try_for_each",0]}]},{"key":{"Type":13},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["MetaSized",0]},{"Ident":["{vtable}",0]}]},{"key":{"Fun":110},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["unzip",0]}]},{"key":{"Fun":83},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["inspect",0]}]},{"key":{"Fun":109},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["rev",0]}]},{"key":{"Fun":155},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_u32",0]}]},{"key":{"Fun":74},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["take_while",0]}]},{"key":{"Fun":209},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["__iterator_get_unchecked",0]}]},{"key":{"Fun":90},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["is_partitioned",0]}]},{"key":{"Fun":94},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["reduce",0]}]},{"key":{"Fun":99},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["find_map",0]}]},{"key":{"Fun":189},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":14}},{"Ident":["ne",0]}]},{"key":{"Fun":28},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]},{"Ident":["backward_unchecked",0]}]},{"key":{"Type":14},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Tuple",0]},{"Ident":["{vtable}",0]}]},{"key":{"Type":1},"value":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Ident":["RandomState",0]}]},{"key":{"Fun":114},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["array_chunks",0]}]},{"key":{"Fun":141},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]},{"Ident":["extend_reserve",0]}]},{"key":{"Fun":30},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]},{"Ident":["clone_from",0]}]},{"key":{"Fun":128},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["is_sorted",0]}]},{"key":{"Fun":159},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_i8",0]}]},{"key":{"Fun":153},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_u8",0]}]},{"key":{"Fun":88},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["partition",0]}]},{"key":{"Fun":0},"value":[{"Ident":["zero_sum_checker",0]},{"Ident":["has_zero_sum_pair",0]}]},{"key":{"Fun":194},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["next",0]}]},{"key":{"Fun":192},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["impls",0]},{"Impl":{"Trait":4}},{"Ident":["hash",0]}]},{"key":{"TraitDecl":4},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]}]},{"key":{"Fun":161},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_i32",0]}]},{"key":{"Fun":24},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]},{"Ident":["forward",0]}]},{"key":{"TraitDecl":21},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Residual",0]}]},{"key":{"Fun":199},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["nth",0]}]},{"key":{"Fun":147},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["rfold",0]}]},{"key":{"Fun":112},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["cloned",0]}]},{"key":{"Fun":31},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["partial_cmp",0]}]},{"key":{"Fun":165},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_length_prefix",0]}]},{"key":{"Fun":89},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["partition_in_place",0]}]},{"key":{"Fun":205},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["find_map",0]}]},{"key":{"TraitDecl":19},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["FromIterator",0]}]},{"key":{"Fun":185},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["__chaining_le",0]}]},{"key":{"Type":6},"value":[{"Ident":["core",0]},{"Ident":["borrow",0]},{"Ident":["Borrow",0]},{"Ident":["{vtable}",0]}]},{"key":{"Fun":123},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["ne",0]}]},{"key":{"Fun":19},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Eq",0]},{"Ident":["assert_receiver_is_total_eq",0]}]},{"key":{"Fun":12},"value":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":10}},{"Ident":["finish",0]}]},{"key":{"Fun":33},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["le",0]}]},{"key":{"TraitDecl":12},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]}]},{"key":{"Fun":87},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["collect_into",0]}]},{"key":{"Fun":93},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["fold",0]}]},{"key":{"Fun":134},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnOnce",0]},{"Ident":["call_once",0]}]},{"key":{"Fun":80},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["flatten",0]}]},{"key":{"TraitDecl":16},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["adapters",0]},{"Ident":["zip",0]},{"Ident":["TrustedRandomAccessNoCoerce",0]}]},{"key":{"Fun":37},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["__chaining_le",0]}]},{"key":{"Fun":3},"value":[{"Ident":["std",0]},{"Ident":["collections",0]},{"Ident":["hash",0]},{"Ident":["set",0]},{"Impl":{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"kind":"InherentImplBlock"}}},{"Ident":["new",0]}]},{"key":{"Fun":136},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]},{"Ident":["branch",0]}]},{"key":{"Fun":171},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}},{"Ident":["steps_between",0]}]},{"key":{"Fun":66},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["intersperse_with",0]}]},{"key":{"TraitDecl":9},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]}]},{"key":{"Fun":9},"value":[{"Ident":["std",0]},{"Ident":["collections",0]},{"Ident":["hash",0]},{"Ident":["set",0]},{"Ident":["HashSet",0]},{"Impl":{"Trait":1}},{"Ident":["drop",0]}]},{"key":{"TraitImpl":4},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["impls",0]},{"Impl":{"Trait":4}}]},{"key":{"Fun":38},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["__chaining_gt",0]}]},{"key":{"Fun":188},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":14}},{"Ident":["eq",0]}]},{"key":{"Fun":168},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":0}},{"Ident":["into_iter",0]}]},{"key":{"Fun":120},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["partial_cmp_by",0]}]},{"key":{"Fun":91},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["try_fold",0]}]},{"key":{"TraitDecl":20},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]}]},{"key":{"Fun":183},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["ge",0]}]},{"key":{"Fun":55},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Impl":{"Trait":7}},{"Ident":["into_iter",0]}]},{"key":{"Fun":11},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["BuildHasher",0]},{"Ident":["build_hasher",0]}]},{"key":{"Fun":15},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write",0]}]},{"key":{"Fun":182},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["gt",0]}]},{"key":{"Fun":95},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["try_reduce",0]}]},{"key":{"Fun":8},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Impl":{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[]}}},"kind":"InherentImplBlock"}}},{"Ident":["len",0]}]},{"key":{"Fun":148},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["rfind",0]}]},{"key":{"Fun":68},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["for_each",0]}]},{"key":{"Fun":59},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["last",0]}]},{"key":{"Fun":184},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["__chaining_lt",0]}]},{"key":{"Fun":140},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]},{"Ident":["extend_one",0]}]},{"key":{"Fun":166},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_str",0]}]},{"key":{"Fun":178},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["impls",0]},{"Impl":{"Trait":12}},{"Ident":["clone",0]}]},{"key":{"Fun":158},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_usize",0]}]},{"key":{"Fun":72},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["peekable",0]}]},{"key":{"Fun":200},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["for_each",0]}]},{"key":{"Fun":130},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["is_sorted_by_key",0]}]},{"key":{"Fun":36},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["__chaining_lt",0]}]},{"key":{"TraitImpl":7},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Impl":{"Trait":7}}]},{"key":{"Fun":53},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]},{"Ident":["clamp",0]}]},{"key":{"Fun":63},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["chain",0]}]},{"key":{"Fun":6},"value":[{"Ident":["std",0]},{"Ident":["collections",0]},{"Ident":["hash",0]},{"Ident":["set",0]},{"Impl":{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"},{"index":1,"name":"S"}],"const_generics":[],"trait_clauses":[null,null,{"clause_id":2,"span":{"span":{"file_id":1,"beg":{"line":447,"col":7},"end":{"line":447,"col":9}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":3,"span":{"span":{"file_id":1,"beg":{"line":447,"col":12},"end":{"line":447,"col":16}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":4,"span":{"span":{"file_id":1,"beg":{"line":448,"col":7},"end":{"line":448,"col":18}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,1]}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}},{"TypeVar":{"Bound":[0,1]}}],"const_generics":[],"trait_refs":[null,null]}}},"kind":"InherentImplBlock"}}},{"Ident":["contains",0]}]},{"key":{"TraitImpl":0},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":0}}]},{"key":{"Fun":118},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["cmp_by",0]}]},{"key":{"Fun":122},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["eq_by",0]}]},{"key":{"Type":7},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]},{"Ident":["{vtable}",0]}]},{"key":{"Type":9},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ordering",0]}]},{"key":{"TraitDecl":26},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Copy",0]}]},{"key":{"Fun":204},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["find",0]}]},{"key":{"Fun":207},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["rposition",0]}]},{"key":{"Fun":124},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["lt",0]}]},{"key":{"Fun":186},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["__chaining_gt",0]}]},{"key":{"TraitImpl":2},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}}]},{"key":{"Fun":127},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["ge",0]}]},{"key":{"Fun":104},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["min",0]}]},{"key":{"TraitDecl":2},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["IntoIterator",0]}]},{"key":{"Fun":14},"value":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":10}},{"Ident":["write_str",0]}]},{"key":{"Fun":7},"value":[{"Ident":["std",0]},{"Ident":["collections",0]},{"Ident":["hash",0]},{"Ident":["set",0]},{"Impl":{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"},{"index":1,"name":"S"}],"const_generics":[],"trait_clauses":[null,null,{"clause_id":2,"span":{"span":{"file_id":1,"beg":{"line":447,"col":7},"end":{"line":447,"col":9}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":3,"span":{"span":{"file_id":1,"beg":{"line":447,"col":12},"end":{"line":447,"col":16}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":4,"span":{"span":{"file_id":1,"beg":{"line":448,"col":7},"end":{"line":448,"col":18}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,1]}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}},{"TypeVar":{"Bound":[0,1]}}],"const_generics":[],"trait_refs":[null,null]}}},"kind":"InherentImplBlock"}}},{"Ident":["insert",0]}]},{"key":{"Fun":17},"value":[{"Ident":["core",0]},{"Ident":["borrow",0]},{"Ident":["Borrow",0]},{"Ident":["borrow",0]}]},{"key":{"TraitImpl":1},"value":[{"Ident":["std",0]},{"Ident":["collections",0]},{"Ident":["hash",0]},{"Ident":["set",0]},{"Ident":["HashSet",0]},{"Impl":{"Trait":1}}]},{"key":{"Fun":106},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["max_by",0]}]},{"key":{"Fun":152},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hash",0]},{"Ident":["hash_slice",0]}]},{"key":{"Fun":18},"value":[{"Ident":["core",0]},{"Ident":["borrow",0]},{"Impl":{"Trait":6}},{"Ident":["borrow",0]}]},{"key":{"Fun":4},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["IntoIterator",0]},{"Ident":["into_iter",0]}]},{"key":{"Fun":27},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]},{"Ident":["backward",0]}]},{"key":{"Fun":25},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]},{"Ident":["forward_unchecked",0]}]},{"key":{"TraitImpl":13},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}}]},{"key":{"TraitImpl":12},"value":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["impls",0]},{"Impl":{"Trait":12}}]},{"key":{"TraitDecl":8},"value":[{"Ident":["core",0]},{"Ident":["borrow",0]},{"Ident":["Borrow",0]}]},{"key":{"TraitImpl":6},"value":[{"Ident":["core",0]},{"Ident":["borrow",0]},{"Impl":{"Trait":6}}]},{"key":{"Type":5},"value":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Ident":["DefaultHasher",0]}]},{"key":{"Fun":64},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["zip",0]}]},{"key":{"TraitImpl":14},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":14}}]},{"key":{"Fun":2},"value":[{"Ident":["zero_sum_checker",0]},{"Ident":["find_zero_sum_pair",0]}]},{"key":{"Fun":143},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["next_back",0]}]},{"key":{"Fun":190},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Sum",0]},{"Ident":["sum",0]}]},{"key":{"Type":4},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["range",0]},{"Ident":["Range",0]}]},{"key":{"Fun":117},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["cmp",0]}]},{"key":{"Fun":193},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["impls",0]},{"Impl":{"Trait":4}},{"Ident":["hash_slice",0]}]},{"key":{"Fun":202},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["all",0]}]},{"key":{"TraitImpl":8},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}}]},{"key":{"Fun":79},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["flat_map",0]}]},{"key":{"Fun":82},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["fuse",0]}]},{"key":{"Fun":5},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["next",0]}]},{"key":{"Fun":46},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["max",0]}]},{"key":{"Fun":61},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["nth",0]}]},{"key":{"Type":12},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["{vtable}",0]}]},{"key":{"Fun":162},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_i64",0]}]},{"key":{"Fun":169},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":11}},{"Ident":["eq",0]}]},{"key":{"Fun":51},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]},{"Ident":["max",0]}]},{"key":{"Fun":69},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["filter",0]}]},{"key":{"Fun":181},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["le",0]}]},{"key":{"Fun":57},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["size_hint",0]}]},{"key":{"Fun":60},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["advance_by",0]}]},{"key":{"TraitDecl":22},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]}]},{"key":{"TraitDecl":23},"value":[{"Ident":["core",0]},{"Ident":["default",0]},{"Ident":["Default",0]}]},{"key":{"Fun":76},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["skip",0]}]},{"key":{"Fun":98},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["find",0]}]},{"key":{"Type":11},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["control_flow",0]},{"Ident":["ControlFlow",0]}]},{"key":{"Fun":41},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["size_hint",0]}]},{"key":{"Fun":151},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hash",0]},{"Ident":["hash",0]}]},{"key":{"Fun":144},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["advance_back_by",0]}]},{"key":{"Fun":81},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["map_windows",0]}]},{"key":{"TraitDecl":11},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]}]},{"key":{"TraitDecl":0},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Sized",0]}]},{"key":{"Fun":58},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["count",0]}]},{"key":{"Global":1},"value":[{"Ident":["core",0]},{"Ident":["borrow",0]},{"Impl":{"Trait":6}},{"Ident":["{vtable}",0]}]},{"key":{"Fun":132},"value":[{"Ident":["core",0]},{"Ident":["default",0]},{"Ident":["Default",0]},{"Ident":["default",0]}]},{"key":{"TraitImpl":3},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":3}}]},{"key":{"Fun":105},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["max_by_key",0]}]},{"key":{"Fun":22},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]},{"Ident":["steps_between",0]}]},{"key":{"Fun":137},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["FromResidual",0]},{"Ident":["from_residual",0]}]},{"key":{"Fun":54},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["adapters",0]},{"Ident":["zip",0]},{"Ident":["TrustedRandomAccessNoCoerce",0]},{"Ident":["size",0]}]},{"key":{"Fun":10},"value":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":5}},{"Ident":["build_hasher",0]}]},{"key":{"Fun":40},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["next",0]}]},{"key":{"Fun":71},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["enumerate",0]}]},{"key":{"Fun":119},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["partial_cmp",0]}]},{"key":{"Fun":133},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnMut",0]},{"Ident":["call_mut",0]}]},{"key":{"Fun":157},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_u128",0]}]},{"key":{"Fun":67},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["map",0]}]},{"key":{"Fun":20},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]},{"Ident":["eq",0]}]},{"key":{"Global":3},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["{vtable}",0]}]},{"key":{"TraitImpl":10},"value":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":10}}]},{"key":{"Fun":107},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["min_by_key",0]}]},{"key":{"Fun":52},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]},{"Ident":["min",0]}]},{"key":{"Fun":176},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}},{"Ident":["backward",0]}]},{"key":{"Fun":84},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["by_ref",0]}]},{"key":{"Fun":164},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_isize",0]}]},{"key":{"Type":0},"value":[{"Ident":["std",0]},{"Ident":["collections",0]},{"Ident":["hash",0]},{"Ident":["set",0]},{"Ident":["HashSet",0]}]},{"key":{"Fun":142},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]},{"Ident":["extend_one_unchecked",0]}]},{"key":{"Fun":16},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["finish",0]}]},{"key":{"Fun":62},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["step_by",0]}]},{"key":{"Fun":126},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["gt",0]}]},{"key":{"Fun":203},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["any",0]}]},{"key":{"Fun":160},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_i16",0]}]},{"key":{"Fun":32},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["lt",0]}]},{"key":{"Fun":125},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["le",0]}]},{"key":{"Global":2},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":11}},{"Ident":["{vtable}",0]}]},{"key":{"Fun":50},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]},{"Ident":["cmp",0]}]},{"key":{"Fun":39},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["__chaining_ge",0]}]},{"key":{"TraitDecl":6},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hash",0]}]},{"key":{"TraitDecl":27},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Sum",0]}]},{"key":{"Fun":187},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["__chaining_ge",0]}]},{"key":{"Fun":191},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Product",0]},{"Ident":["product",0]}]},{"key":{"Fun":102},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["rposition",0]}]},{"key":{"Fun":173},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}},{"Ident":["forward",0]}]},{"key":{"Fun":195},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["size_hint",0]}]},{"key":{"Type":3},"value":[{"Ident":["core",0]},{"Ident":["option",0]},{"Ident":["Option",0]}]},{"key":{"Fun":48},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["is_sorted",0]}]},{"key":{"Type":10},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Destruct",0]},{"Ident":["{vtable}",0]}]},{"key":{"Fun":65},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["intersperse",0]}]},{"key":{"Fun":86},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["try_collect",0]}]},{"key":{"Fun":145},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["nth_back",0]}]},{"key":{"TraitDecl":5},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Eq",0]}]},{"key":{"TraitDecl":14},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Destruct",0]}]},{"key":{"Fun":115},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["sum",0]}]},{"key":{"Fun":45},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["nth",0]}]},{"key":{"Fun":167},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["BuildHasher",0]},{"Ident":["hash_one",0]}]},{"key":{"Fun":198},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["advance_by",0]}]},{"key":{"Fun":47},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["min",0]}]},{"key":{"Fun":103},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["max",0]}]},{"key":{"Fun":49},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["__iterator_get_unchecked",0]}]},{"key":{"Fun":113},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["cycle",0]}]},{"key":{"Fun":85},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["collect",0]}]},{"key":{"Fun":206},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["position",0]}]},{"key":{"Fun":208},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["is_sorted_by",0]}]},{"key":{"TraitImpl":5},"value":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":5}}]},{"key":{"Type":2},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Ident":["Iter",0]}]},{"key":{"Fun":77},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["take",0]}]},{"key":{"Fun":172},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}},{"Ident":["forward_checked",0]}]},{"key":{"Fun":179},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["partial_cmp",0]}]},{"key":{"Fun":23},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]},{"Ident":["forward_checked",0]}]},{"key":{"Fun":56},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["next_chunk",0]}]},{"key":{"TraitDecl":30},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["FromResidual",0]}]},{"key":{"Fun":177},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}},{"Ident":["backward_unchecked",0]}]},{"key":{"TraitImpl":9},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}}]},{"key":{"Fun":75},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["map_while",0]}]},{"key":{"Global":0},"value":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":10}},{"Ident":["{vtable}",0]}]},{"key":{"TraitDecl":29},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Tuple",0]}]},{"key":{"TraitDecl":24},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]}]},{"key":{"Fun":201},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["fold",0]}]},{"key":{"Fun":150},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["exact_size",0]},{"Ident":["ExactSizeIterator",0]},{"Ident":["is_empty",0]}]},{"key":{"Fun":135},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]},{"Ident":["from_output",0]}]},{"key":{"Fun":101},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["position",0]}]},{"key":{"TraitDecl":1},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["MetaSized",0]}]},{"key":{"TraitDecl":28},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Product",0]}]},{"key":{"TraitDecl":17},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnMut",0]}]},{"key":{"Fun":154},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_u16",0]}]},{"key":{"TraitDecl":7},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["BuildHasher",0]}]},{"key":{"Fun":174},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}},{"Ident":["forward_unchecked",0]}]},{"key":{"Fun":197},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["last",0]}]},{"key":{"Type":8},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["{vtable}",0]}]},{"key":{"Fun":175},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}},{"Ident":["backward_checked",0]}]},{"key":{"TraitDecl":13},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]}]},{"key":{"Fun":170},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":11}},{"Ident":["ne",0]}]},{"key":{"Fun":149},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["exact_size",0]},{"Ident":["ExactSizeIterator",0]},{"Ident":["len",0]}]},{"key":{"TraitDecl":3},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["drop",0]},{"Ident":["Drop",0]}]},{"key":{"Fun":21},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]},{"Ident":["ne",0]}]},{"key":{"Fun":116},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["product",0]}]},{"key":{"Fun":26},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]},{"Ident":["backward_checked",0]}]},{"key":{"Fun":34},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["gt",0]}]},{"key":{"Fun":163},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_i128",0]}]},{"key":{"Fun":129},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["is_sorted_by",0]}]},{"key":{"Fun":196},"value":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["count",0]}]},{"key":{"Global":4},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":14}},{"Ident":["{vtable}",0]}]},{"key":{"Fun":139},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]},{"Ident":["extend",0]}]},{"key":{"Fun":138},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["FromIterator",0]},{"Ident":["from_iter",0]}]},{"key":{"Fun":35},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["ge",0]}]},{"key":{"Fun":96},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["all",0]}]},{"key":{"TraitDecl":10},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]}]},{"key":{"Fun":73},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["skip_while",0]}]},{"key":{"Fun":156},"value":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write_u64",0]}]},{"key":{"Fun":108},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["min_by",0]}]},{"key":{"Fun":131},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["__iterator_get_unchecked",0]}]},{"key":{"Fun":70},"value":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["filter_map",0]}]},{"key":{"Fun":13},"value":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":10}},{"Ident":["write",0]}]},{"key":{"TraitImpl":11},"value":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":11}}]}],"short_names":[{"key":{"Fun":44},"value":[{"Impl":{"Trait":8}},{"Ident":["advance_by",0]}]},{"key":{"TraitDecl":28},"value":[{"Ident":["Product",0]}]},{"key":{"Fun":63},"value":[{"Ident":["chain",0]}]},{"key":{"TraitImpl":12},"value":[{"Impl":{"Trait":12}}]},{"key":{"Fun":45},"value":[{"Impl":{"Trait":8}},{"Ident":["nth",0]}]},{"key":{"TraitImpl":2},"value":[{"Impl":{"Trait":2}}]},{"key":{"Fun":177},"value":[{"Impl":{"Trait":9}},{"Ident":["backward_unchecked",0]}]},{"key":{"Fun":163},"value":[{"Ident":["write_i128",0]}]},{"key":{"Fun":195},"value":[{"Impl":{"Trait":2}},{"Ident":["size_hint",0]}]},{"key":{"Fun":12},"value":[{"Impl":{"Trait":10}},{"Ident":["finish",0]}]},{"key":{"Fun":13},"value":[{"Impl":{"Trait":10}},{"Ident":["write",0]}]},{"key":{"Fun":169},"value":[{"Impl":{"Trait":11}},{"Ident":["eq",0]}]},{"key":{"Fun":199},"value":[{"Impl":{"Trait":2}},{"Ident":["nth",0]}]},{"key":{"TraitImpl":8},"value":[{"Impl":{"Trait":8}}]},{"key":{"Fun":181},"value":[{"Impl":{"Trait":13}},{"Ident":["le",0]}]},{"key":{"Fun":10},"value":[{"Impl":{"Trait":5}},{"Ident":["build_hasher",0]}]},{"key":{"Fun":91},"value":[{"Ident":["try_fold",0]}]},{"key":{"Type":4},"value":[{"Ident":["Range",0]}]},{"key":{"Fun":83},"value":[{"Ident":["inspect",0]}]},{"key":{"Fun":205},"value":[{"Impl":{"Trait":2}},{"Ident":["find_map",0]}]},{"key":{"Fun":75},"value":[{"Ident":["map_while",0]}]},{"key":{"TraitImpl":3},"value":[{"Impl":{"Trait":3}}]},{"key":{"TraitImpl":13},"value":[{"Impl":{"Trait":13}}]},{"key":{"Fun":84},"value":[{"Ident":["by_ref",0]}]},{"key":{"Fun":56},"value":[{"Ident":["next_chunk",0]}]},{"key":{"Fun":196},"value":[{"Impl":{"Trait":2}},{"Ident":["count",0]}]},{"key":{"TraitDecl":12},"value":[{"Ident":["Clone",0]}]},{"key":{"Fun":62},"value":[{"Ident":["step_by",0]}]},{"key":{"Fun":164},"value":[{"Ident":["write_isize",0]}]},{"key":{"TraitDecl":3},"value":[{"Ident":["Drop",0]}]},{"key":{"Fun":87},"value":[{"Ident":["collect_into",0]}]},{"key":{"Global":4},"value":[{"Impl":{"Trait":14}},{"Ident":["{vtable}",0]}]},{"key":{"Fun":192},"value":[{"Impl":{"Trait":4}},{"Ident":["hash",0]}]},{"key":{"Fun":202},"value":[{"Impl":{"Trait":2}},{"Ident":["all",0]}]},{"key":{"TraitImpl":4},"value":[{"Impl":{"Trait":4}}]},{"key":{"Fun":80},"value":[{"Ident":["flatten",0]}]},{"key":{"TraitDecl":9},"value":[{"Ident":["Step",0]}]},{"key":{"Fun":81},"value":[{"Ident":["map_windows",0]}]},{"key":{"TraitDecl":10},"value":[{"Ident":["Hasher",0]}]},{"key":{"Fun":132},"value":[{"Ident":["default",0]}]},{"key":{"Fun":1},"value":[{"Ident":["has_zero_sum_pair_brute_force",0]}]},{"key":{"TraitDecl":19},"value":[{"Ident":["FromIterator",0]}]},{"key":{"Fun":48},"value":[{"Impl":{"Trait":8}},{"Ident":["is_sorted",0]}]},{"key":{"Fun":172},"value":[{"Impl":{"Trait":9}},{"Ident":["forward_checked",0]}]},{"key":{"Fun":136},"value":[{"Ident":["branch",0]}]},{"key":{"TraitImpl":6},"value":[{"Impl":{"Trait":6}}]},{"key":{"Fun":89},"value":[{"Ident":["partition_in_place",0]}]},{"key":{"Fun":135},"value":[{"Ident":["from_output",0]}]},{"key":{"TraitDecl":11},"value":[{"Ident":["PartialEq",0]}]},{"key":{"TraitImpl":7},"value":[{"Impl":{"Trait":7}}]},{"key":{"Fun":170},"value":[{"Impl":{"Trait":11}},{"Ident":["ne",0]}]},{"key":{"Fun":200},"value":[{"Impl":{"Trait":2}},{"Ident":["for_each",0]}]},{"key":{"Fun":209},"value":[{"Impl":{"Trait":2}},{"Ident":["__iterator_get_unchecked",0]}]},{"key":{"Fun":46},"value":[{"Impl":{"Trait":8}},{"Ident":["max",0]}]},{"key":{"Fun":53},"value":[{"Ident":["clamp",0]}]},{"key":{"Fun":139},"value":[{"Ident":["extend",0]}]},{"key":{"TraitDecl":14},"value":[{"Ident":["Destruct",0]}]},{"key":{"Fun":188},"value":[{"Impl":{"Trait":14}},{"Ident":["eq",0]}]},{"key":{"Fun":88},"value":[{"Ident":["partition",0]}]},{"key":{"Fun":110},"value":[{"Ident":["unzip",0]}]},{"key":{"Fun":72},"value":[{"Ident":["peekable",0]}]},{"key":{"Fun":19},"value":[{"Ident":["assert_receiver_is_total_eq",0]}]},{"key":{"Fun":185},"value":[{"Impl":{"Trait":13}},{"Ident":["__chaining_le",0]}]},{"key":{"TraitDecl":2},"value":[{"Ident":["IntoIterator",0]}]},{"key":{"Fun":82},"value":[{"Ident":["fuse",0]}]},{"key":{"Fun":69},"value":[{"Ident":["filter",0]}]},{"key":{"Fun":187},"value":[{"Impl":{"Trait":13}},{"Ident":["__chaining_ge",0]}]},{"key":{"Fun":179},"value":[{"Impl":{"Trait":13}},{"Ident":["partial_cmp",0]}]},{"key":{"Fun":148},"value":[{"Ident":["rfind",0]}]},{"key":{"Fun":76},"value":[{"Ident":["skip",0]}]},{"key":{"Fun":147},"value":[{"Ident":["rfold",0]}]},{"key":{"TraitDecl":16},"value":[{"Ident":["TrustedRandomAccessNoCoerce",0]}]},{"key":{"TraitImpl":11},"value":[{"Impl":{"Trait":11}}]},{"key":{"Fun":78},"value":[{"Ident":["scan",0]}]},{"key":{"Fun":184},"value":[{"Impl":{"Trait":13}},{"Ident":["__chaining_lt",0]}]},{"key":{"TraitImpl":0},"value":[{"Impl":{"Trait":0}}]},{"key":{"Fun":146},"value":[{"Ident":["try_rfold",0]}]},{"key":{"Fun":40},"value":[{"Impl":{"Trait":8}},{"Ident":["next",0]}]},{"key":{"Fun":66},"value":[{"Ident":["intersperse_with",0]}]},{"key":{"Type":11},"value":[{"Ident":["ControlFlow",0]}]},{"key":{"Fun":198},"value":[{"Impl":{"Trait":2}},{"Ident":["advance_by",0]}]},{"key":{"Fun":3},"value":[{"Ident":["new",0]}]},{"key":{"TraitDecl":7},"value":[{"Ident":["BuildHasher",0]}]},{"key":{"TraitImpl":10},"value":[{"Impl":{"Trait":10}}]},{"key":{"Fun":174},"value":[{"Impl":{"Trait":9}},{"Ident":["forward_unchecked",0]}]},{"key":{"Fun":157},"value":[{"Ident":["write_u128",0]}]},{"key":{"TraitDecl":20},"value":[{"Ident":["Try",0]}]},{"key":{"TraitDecl":1},"value":[{"Ident":["MetaSized",0]}]},{"key":{"TraitDecl":30},"value":[{"Ident":["FromResidual",0]}]},{"key":{"Fun":85},"value":[{"Ident":["collect",0]}]},{"key":{"Fun":49},"value":[{"Impl":{"Trait":8}},{"Ident":["__iterator_get_unchecked",0]}]},{"key":{"Fun":130},"value":[{"Ident":["is_sorted_by_key",0]}]},{"key":{"Fun":160},"value":[{"Ident":["write_i16",0]}]},{"key":{"Fun":79},"value":[{"Ident":["flat_map",0]}]},{"key":{"Fun":67},"value":[{"Ident":["map",0]}]},{"key":{"Fun":122},"value":[{"Ident":["eq_by",0]}]},{"key":{"Fun":189},"value":[{"Impl":{"Trait":14}},{"Ident":["ne",0]}]},{"key":{"Fun":207},"value":[{"Impl":{"Trait":2}},{"Ident":["rposition",0]}]},{"key":{"Fun":176},"value":[{"Impl":{"Trait":9}},{"Ident":["backward",0]}]},{"key":{"Fun":74},"value":[{"Ident":["take_while",0]}]},{"key":{"TraitDecl":29},"value":[{"Ident":["Tuple",0]}]},{"key":{"Fun":14},"value":[{"Impl":{"Trait":10}},{"Ident":["write_str",0]}]},{"key":{"TraitImpl":5},"value":[{"Impl":{"Trait":5}}]},{"key":{"TraitDecl":15},"value":[{"Ident":["Ord",0]}]},{"key":{"Fun":30},"value":[{"Ident":["clone_from",0]}]},{"key":{"Fun":108},"value":[{"Ident":["min_by",0]}]},{"key":{"TraitDecl":27},"value":[{"Ident":["Sum",0]}]},{"key":{"Fun":186},"value":[{"Impl":{"Trait":13}},{"Ident":["__chaining_gt",0]}]},{"key":{"Type":5},"value":[{"Ident":["DefaultHasher",0]}]},{"key":{"Fun":182},"value":[{"Impl":{"Trait":13}},{"Ident":["gt",0]}]},{"key":{"TraitImpl":14},"value":[{"Impl":{"Trait":14}}]},{"key":{"Fun":143},"value":[{"Ident":["next_back",0]}]},{"key":{"TraitDecl":25},"value":[{"Ident":["ExactSizeIterator",0]}]},{"key":{"Fun":106},"value":[{"Ident":["max_by",0]}]},{"key":{"Fun":156},"value":[{"Ident":["write_u64",0]}]},{"key":{"TraitDecl":4},"value":[{"Ident":["Iterator",0]}]},{"key":{"Fun":178},"value":[{"Impl":{"Trait":12}},{"Ident":["clone",0]}]},{"key":{"Fun":142},"value":[{"Ident":["extend_one_unchecked",0]}]},{"key":{"Fun":41},"value":[{"Impl":{"Trait":8}},{"Ident":["size_hint",0]}]},{"key":{"Fun":47},"value":[{"Impl":{"Trait":8}},{"Ident":["min",0]}]},{"key":{"TraitDecl":8},"value":[{"Ident":["Borrow",0]}]},{"key":{"Fun":150},"value":[{"Ident":["is_empty",0]}]},{"key":{"Fun":183},"value":[{"Impl":{"Trait":13}},{"Ident":["ge",0]}]},{"key":{"Global":3},"value":[{"Impl":{"Trait":13}},{"Ident":["{vtable}",0]}]},{"key":{"Fun":107},"value":[{"Ident":["min_by_key",0]}]},{"key":{"Fun":180},"value":[{"Impl":{"Trait":13}},{"Ident":["lt",0]}]},{"key":{"Fun":2},"value":[{"Ident":["find_zero_sum_pair",0]}]},{"key":{"Fun":86},"value":[{"Ident":["try_collect",0]}]},{"key":{"Fun":42},"value":[{"Impl":{"Trait":8}},{"Ident":["count",0]}]},{"key":{"Fun":70},"value":[{"Ident":["filter_map",0]}]},{"key":{"TraitDecl":17},"value":[{"Ident":["FnMut",0]}]},{"key":{"Fun":65},"value":[{"Ident":["intersperse",0]}]},{"key":{"Fun":141},"value":[{"Ident":["extend_reserve",0]}]},{"key":{"TraitImpl":9},"value":[{"Impl":{"Trait":9}}]},{"key":{"TraitDecl":6},"value":[{"Ident":["Hash",0]}]},{"key":{"Fun":144},"value":[{"Ident":["advance_back_by",0]}]},{"key":{"Fun":9},"value":[{"Ident":["drop",0]}]},{"key":{"Fun":204},"value":[{"Impl":{"Trait":2}},{"Ident":["find",0]}]},{"key":{"Fun":173},"value":[{"Impl":{"Trait":9}},{"Ident":["forward",0]}]},{"key":{"Fun":109},"value":[{"Ident":["rev",0]}]},{"key":{"Fun":105},"value":[{"Ident":["max_by_key",0]}]},{"key":{"Fun":0},"value":[{"Ident":["has_zero_sum_pair",0]}]},{"key":{"Fun":168},"value":[{"Impl":{"Trait":0}},{"Ident":["into_iter",0]}]},{"key":{"Fun":201},"value":[{"Impl":{"Trait":2}},{"Ident":["fold",0]}]},{"key":{"Fun":159},"value":[{"Ident":["write_i8",0]}]},{"key":{"Fun":133},"value":[{"Ident":["call_mut",0]}]},{"key":{"Fun":155},"value":[{"Ident":["write_u32",0]}]},{"key":{"Fun":145},"value":[{"Ident":["nth_back",0]}]},{"key":{"Fun":114},"value":[{"Ident":["array_chunks",0]}]},{"key":{"Type":1},"value":[{"Ident":["RandomState",0]}]},{"key":{"Type":0},"value":[{"Ident":["HashSet",0]}]},{"key":{"Fun":73},"value":[{"Ident":["skip_while",0]}]},{"key":{"TraitDecl":0},"value":[{"Ident":["Sized",0]}]},{"key":{"Fun":54},"value":[{"Ident":["size",0]}]},{"key":{"Fun":134},"value":[{"Ident":["call_once",0]}]},{"key":{"Global":0},"value":[{"Impl":{"Trait":10}},{"Ident":["{vtable}",0]}]},{"key":{"Fun":197},"value":[{"Impl":{"Trait":2}},{"Ident":["last",0]}]},{"key":{"Fun":175},"value":[{"Impl":{"Trait":9}},{"Ident":["backward_checked",0]}]},{"key":{"Fun":90},"value":[{"Ident":["is_partitioned",0]}]},{"key":{"Fun":138},"value":[{"Ident":["from_iter",0]}]},{"key":{"TraitDecl":23},"value":[{"Ident":["Default",0]}]},{"key":{"Type":9},"value":[{"Ident":["Ordering",0]}]},{"key":{"Fun":113},"value":[{"Ident":["cycle",0]}]},{"key":{"Type":3},"value":[{"Ident":["Option",0]}]},{"key":{"TraitDecl":22},"value":[{"Ident":["Extend",0]}]},{"key":{"TraitDecl":26},"value":[{"Ident":["Copy",0]}]},{"key":{"Fun":92},"value":[{"Ident":["try_for_each",0]}]},{"key":{"TraitImpl":1},"value":[{"Impl":{"Trait":1}}]},{"key":{"Global":2},"value":[{"Impl":{"Trait":11}},{"Ident":["{vtable}",0]}]},{"key":{"Fun":162},"value":[{"Ident":["write_i64",0]}]},{"key":{"Fun":158},"value":[{"Ident":["write_usize",0]}]},{"key":{"Fun":153},"value":[{"Ident":["write_u8",0]}]},{"key":{"Fun":118},"value":[{"Ident":["cmp_by",0]}]},{"key":{"Fun":111},"value":[{"Ident":["copied",0]}]},{"key":{"Fun":167},"value":[{"Ident":["hash_one",0]}]},{"key":{"Fun":165},"value":[{"Ident":["write_length_prefix",0]}]},{"key":{"Type":2},"value":[{"Ident":["Iter",0]}]},{"key":{"Fun":95},"value":[{"Ident":["try_reduce",0]}]},{"key":{"Fun":140},"value":[{"Ident":["extend_one",0]}]},{"key":{"Fun":55},"value":[{"Impl":{"Trait":7}},{"Ident":["into_iter",0]}]},{"key":{"Fun":94},"value":[{"Ident":["reduce",0]}]},{"key":{"Fun":208},"value":[{"Impl":{"Trait":2}},{"Ident":["is_sorted_by",0]}]},{"key":{"Fun":71},"value":[{"Ident":["enumerate",0]}]},{"key":{"TraitDecl":13},"value":[{"Ident":["PartialOrd",0]}]},{"key":{"Fun":64},"value":[{"Ident":["zip",0]}]},{"key":{"Fun":120},"value":[{"Ident":["partial_cmp_by",0]}]},{"key":{"Fun":112},"value":[{"Ident":["cloned",0]}]},{"key":{"Fun":43},"value":[{"Impl":{"Trait":8}},{"Ident":["last",0]}]},{"key":{"Fun":193},"value":[{"Impl":{"Trait":4}},{"Ident":["hash_slice",0]}]},{"key":{"Fun":206},"value":[{"Impl":{"Trait":2}},{"Ident":["position",0]}]},{"key":{"Fun":18},"value":[{"Impl":{"Trait":6}},{"Ident":["borrow",0]}]},{"key":{"TraitDecl":21},"value":[{"Ident":["Residual",0]}]},{"key":{"TraitDecl":5},"value":[{"Ident":["Eq",0]}]},{"key":{"Fun":100},"value":[{"Ident":["try_find",0]}]},{"key":{"Fun":203},"value":[{"Impl":{"Trait":2}},{"Ident":["any",0]}]},{"key":{"Fun":137},"value":[{"Ident":["from_residual",0]}]},{"key":{"Fun":6},"value":[{"Ident":["contains",0]}]},{"key":{"Fun":7},"value":[{"Ident":["insert",0]}]},{"key":{"Fun":77},"value":[{"Ident":["take",0]}]},{"key":{"Fun":194},"value":[{"Impl":{"Trait":2}},{"Ident":["next",0]}]},{"key":{"Fun":171},"value":[{"Impl":{"Trait":9}},{"Ident":["steps_between",0]}]},{"key":{"Global":1},"value":[{"Impl":{"Trait":6}},{"Ident":["{vtable}",0]}]},{"key":{"TraitDecl":18},"value":[{"Ident":["FnOnce",0]}]},{"key":{"Fun":161},"value":[{"Ident":["write_i32",0]}]},{"key":{"TraitDecl":24},"value":[{"Ident":["DoubleEndedIterator",0]}]},{"key":{"Fun":154},"value":[{"Ident":["write_u16",0]}]}],"files":[{"name":{"Local":"src/lib.rs"},"crate_name":"zero_sum_checker","contents":"use std::collections::HashSet;\n\n/// Checks if a list of integers contains two numbers that sum to zero.\n/// \n/// This function uses a HashSet for O(n) time complexity.\n/// \n/// # Arguments\n/// \n/// * `numbers` - A slice of integers to check\n/// \n/// # Returns\n/// \n/// * `true` if there are two numbers that sum to zero, `false` otherwise\n/// \n/// # Examples\n/// \n/// ```\n/// use zero_sum_checker::has_zero_sum_pair;\n/// \n/// assert_eq!(has_zero_sum_pair(&[1, 2, -1, 4]), true); // 1 + -1 = 0\n/// assert_eq!(has_zero_sum_pair(&[1, 2, 3, 4]), false);\n/// assert_eq!(has_zero_sum_pair(&[0, 0, 5, 10]), true); // 0 + 0 = 0 \n/// assert_eq!(has_zero_sum_pair(&[0]), false); // Only one number\n/// ```\npub fn has_zero_sum_pair(numbers: &[i32]) -> bool {\n    let mut seen = HashSet::new();\n    \n    for &num in numbers {\n        let complement = -num;\n        if seen.contains(&complement) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    \n    false\n}\n\n/// Alternative implementation with O(n²) time complexity but O(1) space complexity.\n/// \n/// This is a brute force approach that checks all pairs.\n/// \n/// # Arguments\n/// \n/// * `numbers` - A slice of integers to check\n/// \n/// # Returns\n/// \n/// * `true` if there are two numbers that sum to zero, `false` otherwise\npub fn has_zero_sum_pair_brute_force(numbers: &[i32]) -> bool {\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n            if numbers[i] + numbers[j] == 0 {\n                return true;\n            }\n        }\n    }\n    false\n}\n\n/// Finds and returns the first pair of numbers that sum to zero.\n/// \n/// # Arguments\n/// \n/// * `numbers` - A list of integers to check\n/// \n/// # Returns\n/// \n/// * `Some((a, b))` where a + b = 0, or `None` if no such pair exists\n/// \n/// # Examples\n/// \n/// ```\n/// use zero_sum_checker::find_zero_sum_pair;\n/// \n/// assert_eq!(find_zero_sum_pair(&[1, 2, -1, 4]), Some((1, -1)));\n/// assert_eq!(find_zero_sum_pair(&[1, 2, 3, 4]), None);\n/// ```\npub fn find_zero_sum_pair(numbers: &[i32]) -> Option<(i32, i32)> {\n    let mut seen = HashSet::new();\n    \n    for &num in numbers {\n        let complement = -num;\n        if seen.contains(&complement) {\n            return Some((complement, num));\n        }\n        seen.insert(num);\n    }\n    \n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_has_zero_sum_pair() {\n        // Test cases with zero sum pairs\n        assert!(has_zero_sum_pair(&[1, 2, -1, 4]));\n        assert!(has_zero_sum_pair(&[5, -3, 2, -2, 8]));\n        assert!(has_zero_sum_pair(&[-1, 0, 1, 2]));\n        assert!(has_zero_sum_pair(&[3, -3]));\n        \n        // Test cases without zero sum pairs\n        assert!(!has_zero_sum_pair(&[1, 2, 3, 4]));\n        assert!(!has_zero_sum_pair(&[1, 2, 4, 8]));\n        assert!(!has_zero_sum_pair(&[-1, -2, -3, -4]));\n        \n        // Edge cases\n        assert!(!has_zero_sum_pair(&[])); // Empty array\n        assert!(!has_zero_sum_pair(&[5])); // Single element\n        assert!(!has_zero_sum_pair(&[0])); // Single zero\n        assert!(has_zero_sum_pair(&[0, 0])); // Two zeros\n        assert!(!has_zero_sum_pair(&[0, 1, 2])); // Zero with other numbers\n    }\n\n    #[test]\n    fn test_brute_force_implementation() {\n        // Test that both implementations give the same results\n        let test_cases = vec![\n            vec![1, 2, -1, 4],\n            vec![1, 2, 3, 4],\n            vec![5, -3, 2, -2, 8],\n            vec![-1, 0, 1, 2],\n            vec![],\n            vec![5],\n            vec![0, 0],\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                has_zero_sum_pair(&test_case),\n                has_zero_sum_pair_brute_force(&test_case),\n                \"Implementations disagree on test case: {:?}\",\n                test_case\n            );\n        }\n    }\n\n    #[test]\n    fn test_find_zero_sum_pair() {\n        // Test finding actual pairs\n        match find_zero_sum_pair(&[1, 2, -1, 4]) {\n            Some((a, b)) => assert_eq!(a + b, 0),\n            None => panic!(\"Should have found a pair\"),\n        }\n\n        match find_zero_sum_pair(&[5, -3, 2, -2, 8]) {\n            Some((a, b)) => assert_eq!(a + b, 0),\n            None => panic!(\"Should have found a pair\"),\n        }\n\n        // Test cases with no pairs\n        assert_eq!(find_zero_sum_pair(&[1, 2, 3, 4]), None);\n        assert_eq!(find_zero_sum_pair(&[]), None);\n        assert_eq!(find_zero_sum_pair(&[5]), None);\n    }\n}"},{"name":{"Local":"/rustc/library/std/src/collections/hash/set.rs"},"crate_name":"std","contents":null},{"name":{"Local":"/rustc/library/std/src/collections/hash/mod.rs"},"crate_name":"std","contents":null},{"name":{"Local":"/rustc/library/std/src/collections/mod.rs"},"crate_name":"std","contents":null},{"name":{"Local":"/rustc/library/std/src/lib.rs"},"crate_name":"std","contents":null},{"name":{"Local":"/rustc/library/std/src/hash/random.rs"},"crate_name":"std","contents":null},{"name":{"Local":"/rustc/library/std/src/hash/mod.rs"},"crate_name":"std","contents":null},{"name":{"Local":"/rustc/library/core/src/marker.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/lib.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/slice/iter.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/slice/mod.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/option.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/iter/traits/collect.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/iter/traits/mod.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/iter/mod.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/ops/drop.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/ops/mod.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/iter/traits/iterator.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/slice/iter/macros.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/cmp.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/hash/mod.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/borrow.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/ops/range.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/iter/range.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/clone.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/iter/adapters/zip.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/iter/adapters/mod.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/ops/function.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/ops/try_trait.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/default.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/iter/traits/double_ended.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/iter/traits/exact_size.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/iter/traits/accum.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/ops/control_flow.rs"},"crate_name":"core","contents":null}],"type_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["collections",0]},{"Ident":["hash",0]},{"Ident":["set",0]},{"Ident":["HashSet",0]}],"span":{"span":{"file_id":1,"beg":{"line":125,"col":0},"end":{"line":125,"col":38}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A [hash set] implemented as a `HashMap` where the value is `()`."},{"DocComment":""},{"DocComment":" As with the [`HashMap`] type, a `HashSet` requires that the elements"},{"DocComment":" implement the [`Eq`] and [`Hash`] traits. This can frequently be achieved by"},{"DocComment":" using `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself,"},{"DocComment":" it is important that the following property holds:"},{"DocComment":""},{"DocComment":" ```text"},{"DocComment":" k1 == k2 -> hash(k1) == hash(k2)"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" In other words, if two keys are equal, their hashes must be equal."},{"DocComment":" Violating this property is a logic error."},{"DocComment":""},{"DocComment":" It is also a logic error for a key to be modified in such a way that the key's"},{"DocComment":" hash, as determined by the [`Hash`] trait, or its equality, as determined by"},{"DocComment":" the [`Eq`] trait, changes while it is in the map. This is normally only"},{"DocComment":" possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code."},{"DocComment":""},{"DocComment":" The behavior resulting from either logic error is not specified, but will"},{"DocComment":" be encapsulated to the `HashSet` that observed the logic error and not"},{"DocComment":" result in undefined behavior. This could include panics, incorrect results,"},{"DocComment":" aborts, memory leaks, and non-termination."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::collections::HashSet;"},{"DocComment":" // Type inference lets us omit an explicit type signature (which"},{"DocComment":" // would be `HashSet<String>` in this example)."},{"DocComment":" let mut books = HashSet::new();"},{"DocComment":""},{"DocComment":" // Add some books."},{"DocComment":" books.insert(\"A Dance With Dragons\".to_string());"},{"DocComment":" books.insert(\"To Kill a Mockingbird\".to_string());"},{"DocComment":" books.insert(\"The Odyssey\".to_string());"},{"DocComment":" books.insert(\"The Great Gatsby\".to_string());"},{"DocComment":""},{"DocComment":" // Check for a specific one."},{"DocComment":" if !books.contains(\"The Winds of Winter\") {"},{"DocComment":"     println!(\"We have {} books, but The Winds of Winter ain't one.\","},{"DocComment":"              books.len());"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Remove a book."},{"DocComment":" books.remove(\"The Odyssey\");"},{"DocComment":""},{"DocComment":" // Iterate over everything."},{"DocComment":" for book in &books {"},{"DocComment":"     println!(\"{book}\");"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The easiest way to use `HashSet` with a custom type is to derive"},{"DocComment":" [`Eq`] and [`Hash`]. We must also derive [`PartialEq`],"},{"DocComment":" which is required if [`Eq`] is derived."},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::collections::HashSet;"},{"DocComment":" #[derive(Hash, Eq, PartialEq, Debug)]"},{"DocComment":" struct Viking {"},{"DocComment":"     name: String,"},{"DocComment":"     power: usize,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let mut vikings = HashSet::new();"},{"DocComment":""},{"DocComment":" vikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });"},{"DocComment":" vikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });"},{"DocComment":" vikings.insert(Viking { name: \"Olaf\".to_string(), power: 4 });"},{"DocComment":" vikings.insert(Viking { name: \"Harald\".to_string(), power: 8 });"},{"DocComment":""},{"DocComment":" // Use derived implementation to print the vikings."},{"DocComment":" for x in &vikings {"},{"DocComment":"     println!(\"{x:?}\");"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" A `HashSet` with a known list of items can be initialized from an array:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::collections::HashSet;"},{"DocComment":""},{"DocComment":" let viking_names = HashSet::from([\"Einar\", \"Olaf\", \"Harald\"]);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [hash set]: crate::collections#use-the-set-variant-of-any-of-these-maps-when"},{"DocComment":" [`HashMap`]: crate::collections::HashMap"},{"DocComment":" [`RefCell`]: crate::cell::RefCell"},{"DocComment":" [`Cell`]: crate::cell::Cell"},{"DocComment":""},{"DocComment":" # Usage in `const` and `static`"},{"DocComment":""},{"DocComment":" Like `HashMap`, `HashSet` is randomly seeded: each `HashSet` instance uses a different seed,"},{"DocComment":" which means that `HashSet::new` cannot be used in const context. To construct a `HashSet` in the"},{"DocComment":" initializer of a `const` or `static` item, you will have to use a different hasher that does not"},{"DocComment":" involve a random seed, as demonstrated in the following example. **A `HashSet` constructed this"},{"DocComment":" way is not resistant against HashDoS!**"},{"DocComment":""},{"DocComment":" ```rust"},{"DocComment":" use std::collections::HashSet;"},{"DocComment":" use std::hash::{BuildHasherDefault, DefaultHasher};"},{"DocComment":" use std::sync::Mutex;"},{"DocComment":""},{"DocComment":" const EMPTY_SET: HashSet<String, BuildHasherDefault<DefaultHasher>> ="},{"DocComment":"     HashSet::with_hasher(BuildHasherDefault::new());"},{"DocComment":" static SET: Mutex<HashSet<String, BuildHasherDefault<DefaultHasher>>> ="},{"DocComment":"     Mutex::new(HashSet::with_hasher(BuildHasherDefault::new()));"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"HashSet\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"HashSet"},"generics":{"regions":[],"types":[{"index":0,"name":"T"},{"index":1,"name":"S"}],"const_generics":[],"trait_clauses":[null,null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"src":"TopLevel","kind":"Opaque","layout":null,"ptr_metadata":"None"},{"def_id":1,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Ident":["RandomState",0]}],"span":{"span":{"file_id":5,"beg":{"line":36,"col":0},"end":{"line":36,"col":22}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" `RandomState` is the default state for [`HashMap`] types."},{"DocComment":""},{"DocComment":" A particular instance `RandomState` will create the same instances of"},{"DocComment":" [`Hasher`], but the hashers created by two different `RandomState`"},{"DocComment":" instances are unlikely to produce the same result for the same values."},{"DocComment":""},{"DocComment":" [`HashMap`]: crate::collections::HashMap"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::collections::HashMap;"},{"DocComment":" use std::hash::RandomState;"},{"DocComment":""},{"DocComment":" let s = RandomState::new();"},{"DocComment":" let mut map = HashMap::with_hasher(s);"},{"DocComment":" map.insert(1, 2);"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"src":"TopLevel","kind":"Opaque","layout":{"size":16,"align":8,"discriminant_layout":null,"uninhabited":false,"variant_layouts":[{"field_offsets":[0,8],"uninhabited":false,"tag":null}]},"ptr_metadata":"None"},{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Ident":["Iter",0]}],"span":{"span":{"file_id":9,"beg":{"line":69,"col":0},"end":{"line":69,"col":26}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Immutable slice iterator"},{"DocComment":""},{"DocComment":" This struct is created by the [`iter`] method on [slices]."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // First, we need a slice to call the `iter` method on:"},{"DocComment":" let slice = &[1, 2, 3];"},{"DocComment":""},{"DocComment":" // Then we call `iter` on the slice to get the `Iter` iterator,"},{"DocComment":" // and iterate over it:"},{"DocComment":" for element in slice.iter() {"},{"DocComment":"     println!(\"{element}\");"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // This for loop actually already works without calling `iter`:"},{"DocComment":" for element in slice {"},{"DocComment":"     println!(\"{element}\");"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`iter`]: slice::iter"},{"DocComment":" [slices]: slice"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"SliceIter\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"SliceIter"},"generics":{"regions":[{"index":0,"name":"'a"}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[{"regions":[],"skip_binder":[{"TypeVar":{"Free":0}},{"Var":{"Free":0}}]},{"regions":[],"skip_binder":[{"TypeVar":{"Free":0}},{"Var":{"Free":0}}]}],"trait_type_constraints":[]},"src":"TopLevel","kind":"Opaque","layout":{"size":16,"align":8,"discriminant_layout":null,"uninhabited":false,"variant_layouts":[{"field_offsets":[0,8,16],"uninhabited":false,"tag":null}]},"ptr_metadata":"None"},{"def_id":3,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["option",0]},{"Ident":["Option",0]}],"span":{"span":{"file_id":11,"beg":{"line":591,"col":0},"end":{"line":591,"col":18}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The `Option` type. See [the module level documentation](self) for more."},{"Unknown":{"path":"doc","args":"search_unbox"}},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"Option\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Option"},"generics":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"src":"TopLevel","kind":{"Enum":[{"span":{"span":{"file_id":11,"beg":{"line":595,"col":4},"end":{"line":595,"col":8}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" No value."}],"inline":null,"rename":null,"public":true},"name":"None","fields":[],"discriminant":{"Signed":["Isize","0"]}},{"span":{"span":{"file_id":11,"beg":{"line":599,"col":4},"end":{"line":599,"col":8}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" Some value of type `T`."}],"inline":null,"rename":null,"public":true},"name":"Some","fields":[{"span":{"span":{"file_id":11,"beg":{"line":599,"col":55},"end":{"line":599,"col":56}},"generated_from_span":null},"attr_info":{"attributes":[],"inline":null,"rename":null,"public":true},"name":null,"ty":{"TypeVar":{"Free":0}}}],"discriminant":{"Signed":["Isize","1"]}}]},"layout":null,"ptr_metadata":"None"},{"def_id":4,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["range",0]},{"Ident":["Range",0]}],"span":{"span":{"file_id":22,"beg":{"line":80,"col":0},"end":{"line":80,"col":21}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A (half-open) range bounded inclusively below and exclusively above"},{"DocComment":" (`start..end`)."},{"DocComment":""},{"DocComment":" The range `start..end` contains all values with `start <= x < end`."},{"DocComment":" It is empty if `start >= end`."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" The `start..end` syntax is a `Range`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });"},{"DocComment":" assert_eq!(3 + 4 + 5, (3..6).sum());"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let arr = [0, 1, 2, 3, 4];"},{"DocComment":" assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);"},{"DocComment":" assert_eq!(arr[ .. 3], [0, 1, 2      ]);"},{"DocComment":" assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);"},{"DocComment":" assert_eq!(arr[1..  ], [   1, 2, 3, 4]);"},{"DocComment":" assert_eq!(arr[1.. 3], [   1, 2      ]); // This is a `Range`"},{"DocComment":" assert_eq!(arr[1..=3], [   1, 2, 3   ]);"},{"DocComment":" ```"},{"Unknown":{"path":"doc","args":"alias = \"..\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Range"},"generics":{"regions":[],"types":[{"index":0,"name":"Idx"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"src":"TopLevel","kind":{"Struct":[{"span":{"span":{"file_id":22,"beg":{"line":83,"col":4},"end":{"line":83,"col":18}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" The lower bound of the range (inclusive)."}],"inline":null,"rename":null,"public":true},"name":"start","ty":{"TypeVar":{"Free":0}}},{"span":{"span":{"file_id":22,"beg":{"line":86,"col":4},"end":{"line":86,"col":16}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" The upper bound of the range (exclusive)."}],"inline":null,"rename":null,"public":true},"name":"end","ty":{"TypeVar":{"Free":0}}}]},"layout":null,"ptr_metadata":null},{"def_id":5,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Ident":["DefaultHasher",0]}],"span":{"span":{"file_id":5,"beg":{"line":97,"col":0},"end":{"line":97,"col":24}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The default [`Hasher`] used by [`RandomState`]."},{"DocComment":""},{"DocComment":" The internal algorithm is not specified, and so it and its hashes should"},{"DocComment":" not be relied upon over releases."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"src":"TopLevel","kind":"Opaque","layout":{"size":72,"align":8,"discriminant_layout":null,"uninhabited":false,"variant_layouts":[{"field_offsets":[0],"uninhabited":false,"tag":null}]},"ptr_metadata":"None"},null,null,null,{"def_id":9,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ordering",0]}],"span":{"span":{"file_id":19,"beg":{"line":391,"col":0},"end":{"line":391,"col":17}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" An `Ordering` is the result of a comparison between two values."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" assert_eq!(1.cmp(&2), Ordering::Less);"},{"DocComment":""},{"DocComment":" assert_eq!(1.cmp(&1), Ordering::Equal);"},{"DocComment":""},{"DocComment":" assert_eq!(2.cmp(&1), Ordering::Greater);"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Ordering"},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"src":"TopLevel","kind":{"Enum":[{"span":{"span":{"file_id":19,"beg":{"line":394,"col":4},"end":{"line":394,"col":8}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" An ordering where a compared value is less than another."}],"inline":null,"rename":null,"public":true},"name":"Less","fields":[],"discriminant":{"Signed":["I8","-1"]}},{"span":{"span":{"file_id":19,"beg":{"line":397,"col":4},"end":{"line":397,"col":9}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" An ordering where a compared value is equal to another."}],"inline":null,"rename":null,"public":true},"name":"Equal","fields":[],"discriminant":{"Signed":["I8","0"]}},{"span":{"span":{"file_id":19,"beg":{"line":400,"col":4},"end":{"line":400,"col":11}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" An ordering where a compared value is greater than another."}],"inline":null,"rename":null,"public":true},"name":"Greater","fields":[],"discriminant":{"Signed":["I8","1"]}}]},"layout":{"size":1,"align":1,"discriminant_layout":{"offset":0,"tag_ty":{"Signed":"I8"},"encoding":"Direct"},"uninhabited":false,"variant_layouts":[{"field_offsets":[],"uninhabited":false,"tag":{"Signed":["I8","-1"]}},{"field_offsets":[],"uninhabited":false,"tag":{"Signed":["I8","0"]}},{"field_offsets":[],"uninhabited":false,"tag":{"Signed":["I8","1"]}}]},"ptr_metadata":"None"},null,{"def_id":11,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["control_flow",0]},{"Ident":["ControlFlow",0]}],"span":{"span":{"file_id":33,"beg":{"line":87,"col":0},"end":{"line":87,"col":31}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Used to tell an operation whether it should exit early or go on as usual."},{"DocComment":""},{"DocComment":" This is used when exposing things (like graph traversals or visitors) where"},{"DocComment":" you want the user to be able to choose whether to exit early."},{"DocComment":" Having the enum makes it clearer -- no more wondering \"wait, what did `false`"},{"DocComment":" mean again?\" -- and allows including a value."},{"DocComment":""},{"DocComment":" Similar to [`Option`] and [`Result`], this enum can be used with the `?` operator"},{"DocComment":" to return immediately if the [`Break`] variant is present or otherwise continue normally"},{"DocComment":" with the value inside the [`Continue`] variant."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Early-exiting from [`Iterator::try_for_each`]:"},{"DocComment":" ```"},{"DocComment":" use std::ops::ControlFlow;"},{"DocComment":""},{"DocComment":" let r = (2..100).try_for_each(|x| {"},{"DocComment":"     if 403 % x == 0 {"},{"DocComment":"         return ControlFlow::Break(x)"},{"DocComment":"     }"},{"DocComment":""},{"DocComment":"     ControlFlow::Continue(())"},{"DocComment":" });"},{"DocComment":" assert_eq!(r, ControlFlow::Break(13));"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" A basic tree traversal:"},{"DocComment":" ```"},{"DocComment":" use std::ops::ControlFlow;"},{"DocComment":""},{"DocComment":" pub struct TreeNode<T> {"},{"DocComment":"     value: T,"},{"DocComment":"     left: Option<Box<TreeNode<T>>>,"},{"DocComment":"     right: Option<Box<TreeNode<T>>>,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl<T> TreeNode<T> {"},{"DocComment":"     pub fn traverse_inorder<B>(&self, f: &mut impl FnMut(&T) -> ControlFlow<B>) -> ControlFlow<B> {"},{"DocComment":"         if let Some(left) = &self.left {"},{"DocComment":"             left.traverse_inorder(f)?;"},{"DocComment":"         }"},{"DocComment":"         f(&self.value)?;"},{"DocComment":"         if let Some(right) = &self.right {"},{"DocComment":"             right.traverse_inorder(f)?;"},{"DocComment":"         }"},{"DocComment":"         ControlFlow::Continue(())"},{"DocComment":"     }"},{"DocComment":"     fn leaf(value: T) -> Option<Box<TreeNode<T>>> {"},{"DocComment":"         Some(Box::new(Self { value, left: None, right: None }))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let node = TreeNode {"},{"DocComment":"     value: 0,"},{"DocComment":"     left: TreeNode::leaf(1),"},{"DocComment":"     right: Some(Box::new(TreeNode {"},{"DocComment":"         value: -1,"},{"DocComment":"         left: TreeNode::leaf(5),"},{"DocComment":"         right: TreeNode::leaf(2),"},{"DocComment":"     }))"},{"DocComment":" };"},{"DocComment":" let mut sum = 0;"},{"DocComment":""},{"DocComment":" let res = node.traverse_inorder(&mut |val| {"},{"DocComment":"     if *val < 0 {"},{"DocComment":"         ControlFlow::Break(*val)"},{"DocComment":"     } else {"},{"DocComment":"         sum += *val;"},{"DocComment":"         ControlFlow::Continue(())"},{"DocComment":"     }"},{"DocComment":" });"},{"DocComment":" assert_eq!(res, ControlFlow::Break(-1));"},{"DocComment":" assert_eq!(sum, 6);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`Break`]: ControlFlow::Break"},{"DocComment":" [`Continue`]: ControlFlow::Continue"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"ControlFlow\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"ControlFlow"},"generics":{"regions":[],"types":[{"index":0,"name":"B"},{"index":1,"name":"C"}],"const_generics":[],"trait_clauses":[null,null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"src":"TopLevel","kind":{"Enum":[{"span":{"span":{"file_id":33,"beg":{"line":91,"col":4},"end":{"line":91,"col":12}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" Move on to the next phase of the operation as normal."}],"inline":null,"rename":null,"public":true},"name":"Continue","fields":[{"span":{"span":{"file_id":33,"beg":{"line":91,"col":13},"end":{"line":91,"col":14}},"generated_from_span":null},"attr_info":{"attributes":[],"inline":null,"rename":null,"public":true},"name":null,"ty":{"TypeVar":{"Free":1}}}],"discriminant":{"Signed":["Isize","0"]}},{"span":{"span":{"file_id":33,"beg":{"line":95,"col":4},"end":{"line":95,"col":9}},"generated_from_span":null},"attr_info":{"attributes":[{"DocComment":" Exit the operation without running subsequent phases."}],"inline":null,"rename":null,"public":true},"name":"Break","fields":[{"span":{"span":{"file_id":33,"beg":{"line":95,"col":10},"end":{"line":95,"col":11}},"generated_from_span":null},"attr_info":{"attributes":[],"inline":null,"rename":null,"public":true},"name":null,"ty":{"TypeVar":{"Free":0}}}],"discriminant":{"Signed":["Isize","1"]}}]},"layout":null,"ptr_metadata":"None"},null,null,null],"fun_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["zero_sum_checker",0]},{"Ident":["has_zero_sum_pair",0]}],"span":{"span":{"file_id":0,"beg":{"line":25,"col":0},"end":{"line":37,"col":1}},"generated_from_span":null},"source_text":"pub fn has_zero_sum_pair(numbers: &[i32]) -> bool {\n    let mut seen = HashSet::new();\n    \n    for &num in numbers {\n        let complement = -num;\n        if seen.contains(&complement) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    \n    false\n}","attr_info":{"attributes":[{"DocComment":" Checks if a list of integers contains two numbers that sum to zero."},{"DocComment":" "},{"DocComment":" This function uses a HashSet for O(n) time complexity."},{"DocComment":" "},{"DocComment":" # Arguments"},{"DocComment":" "},{"DocComment":" * `numbers` - A slice of integers to check"},{"DocComment":" "},{"DocComment":" # Returns"},{"DocComment":" "},{"DocComment":" * `true` if there are two numbers that sum to zero, `false` otherwise"},{"DocComment":" "},{"DocComment":" # Examples"},{"DocComment":" "},{"DocComment":" ```"},{"DocComment":" use zero_sum_checker::has_zero_sum_pair;"},{"DocComment":" "},{"DocComment":" assert_eq!(has_zero_sum_pair(&[1, 2, -1, 4]), true); // 1 + -1 = 0"},{"DocComment":" assert_eq!(has_zero_sum_pair(&[1, 2, 3, 4]), false);"},{"DocComment":" assert_eq!(has_zero_sum_pair(&[0, 0, 5, 10]), true); // 0 + 0 = 0 "},{"DocComment":" assert_eq!(has_zero_sum_pair(&[0]), false); // Only one number"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":true,"opacity":"Transparent","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}],"output":{"Literal":"Bool"}},"kind":"TopLevel","is_global_initializer":null,"body":{"Ok":{"Structured":{"span":{"span":{"file_id":0,"beg":{"line":25,"col":0},"end":{"line":37,"col":1}},"generated_from_span":null},"locals":{"arg_count":1,"locals":[{"index":0,"name":null,"ty":{"Literal":"Bool"}},{"index":1,"name":"numbers","ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"index":2,"name":"seen","ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},{"index":3,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":4,"name":null,"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":5,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"index":6,"name":"iter","ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":7,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":8,"name":null,"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[null]}}}},{"index":9,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"index":10,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"index":11,"name":"num","ty":{"Literal":{"Int":"I32"}}},{"index":12,"name":"complement","ty":{"Literal":{"Int":"I32"}}},{"index":13,"name":null,"ty":{"Literal":{"Int":"I32"}}},{"index":14,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":15,"name":null,"ty":{"Literal":"Bool"}},{"index":16,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Shared"]}},{"index":17,"name":null,"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"index":18,"name":null,"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"index":19,"name":null,"ty":{"Literal":"Bool"}},{"index":20,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Mut"]}},{"index":21,"name":null,"ty":{"Literal":{"Int":"I32"}}}]},"comments":[],"body":{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":37,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":358,"content":{"StorageLive":9},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":359,"content":{"StorageLive":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":360,"content":{"StorageLive":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":361,"content":{"StorageLive":13},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":362,"content":{"StorageLive":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":363,"content":{"StorageLive":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":364,"content":{"StorageLive":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":365,"content":{"StorageLive":17},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":366,"content":{"StorageLive":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":367,"content":{"StorageLive":19},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":368,"content":{"StorageLive":20},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":369,"content":{"StorageLive":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":8},"end":{"line":26,"col":16}},"generated_from_span":null},"id":97,"content":{"StorageLive":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":26,"col":19},"end":{"line":26,"col":33}},"generated_from_span":null},"id":96,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":3}},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"args":[],"dest":{"kind":{"Local":2},"ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":92,"content":{"StorageLive":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":93,"content":{"StorageLive":4},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":94,"content":{"StorageLive":5},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":95,"content":{"Assign":[{"kind":{"Local":5},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"Use":{"Copy":{"kind":{"Local":1},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":91,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":168}},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"args":[{"Move":{"kind":{"Local":5},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}}}],"dest":{"kind":{"Local":4},"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":22},"end":{"line":28,"col":23}},"generated_from_span":null},"id":88,"content":{"StorageDead":5},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":89,"content":{"StorageLive":6},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":90,"content":{"Assign":[{"kind":{"Local":6},"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}},{"Use":{"Move":{"kind":{"Local":4},"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":4},"end":{"line":37,"col":1}},"generated_from_span":null},"id":75,"content":{"Loop":{"span":{"span":{"file_id":0,"beg":{"line":28,"col":4},"end":{"line":37,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":69,"content":{"StorageLive":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":70,"content":{"StorageLive":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":71,"content":{"StorageLive":9},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":72,"content":{"StorageLive":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":73,"content":{"Assign":[{"kind":{"Local":10},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"Ref":[{"kind":{"Local":6},"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}},"Mut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":74,"content":{"Assign":[{"kind":{"Local":9},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":10},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},"Deref"]},"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}},"TwoPhaseMut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":68,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":194}},"generics":{"regions":["Erased","Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"args":[{"Move":{"kind":{"Local":9},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}}}],"dest":{"kind":{"Local":8},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[null]}}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":22},"end":{"line":28,"col":23}},"generated_from_span":null},"id":66,"content":{"StorageDead":9},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":4},"end":{"line":37,"col":1}},"generated_from_span":null},"id":65,"content":{"Switch":{"Match":[{"kind":{"Local":8},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[null]}}}},[[[0],{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":28,"col":16},"end":{"line":28,"col":23}},"generated_from_span":null},"id":0,"content":{"Break":0},"comments_before":[]}]}],[[1],{"span":{"span":{"file_id":0,"beg":{"line":28,"col":4},"end":{"line":37,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":28,"col":9},"end":{"line":28,"col":12}},"generated_from_span":null},"id":47,"content":{"StorageLive":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":9},"end":{"line":28,"col":12}},"generated_from_span":null},"id":48,"content":{"Assign":[{"kind":{"Local":11},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Projection":[{"kind":{"Projection":[{"kind":{"Local":8},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[null]}}}},{"Field":[{"Adt":[3,1]},0]}]},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},"Deref"]},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":29,"col":12},"end":{"line":29,"col":22}},"generated_from_span":null},"id":49,"content":{"StorageLive":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":29,"col":26},"end":{"line":29,"col":29}},"generated_from_span":null},"id":50,"content":{"StorageLive":13},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":29,"col":26},"end":{"line":29,"col":29}},"generated_from_span":null},"id":51,"content":{"Assign":[{"kind":{"Local":13},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Local":11},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":29,"col":25},"end":{"line":29,"col":29}},"generated_from_span":null},"id":54,"content":{"Assign":[{"kind":{"Local":12},"ty":{"Literal":{"Int":"I32"}}},{"UnaryOp":[{"Neg":"Panic"},{"Move":{"kind":{"Local":13},"ty":{"Literal":{"Int":"I32"}}}}]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":29,"col":28},"end":{"line":29,"col":29}},"generated_from_span":null},"id":55,"content":{"StorageDead":13},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":8},"end":{"line":32,"col":9}},"generated_from_span":null},"id":56,"content":{"StorageLive":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":11},"end":{"line":30,"col":37}},"generated_from_span":null},"id":57,"content":{"StorageLive":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":11},"end":{"line":30,"col":15}},"generated_from_span":null},"id":58,"content":{"StorageLive":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":11},"end":{"line":30,"col":15}},"generated_from_span":null},"id":59,"content":{"Assign":[{"kind":{"Local":16},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Shared"]}},{"Ref":[{"kind":{"Local":2},"ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":25},"end":{"line":30,"col":36}},"generated_from_span":null},"id":60,"content":{"StorageLive":17},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":25},"end":{"line":30,"col":36}},"generated_from_span":null},"id":61,"content":{"StorageLive":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":25},"end":{"line":30,"col":36}},"generated_from_span":null},"id":62,"content":{"Assign":[{"kind":{"Local":18},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"Ref":[{"kind":{"Local":12},"ty":{"Literal":{"Int":"I32"}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":25},"end":{"line":30,"col":36}},"generated_from_span":null},"id":63,"content":{"Assign":[{"kind":{"Local":17},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":18},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},"Deref"]},"ty":{"Literal":{"Int":"I32"}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":11},"end":{"line":30,"col":37}},"generated_from_span":null},"id":46,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":6}},"generics":{"regions":["Erased","Erased"],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null,{"kind":{"TraitImpl":{"id":3,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":4,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":5,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[]}}}},null,{"kind":{"TraitImpl":{"id":6,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":8,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":4,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":3,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}}]}}},"args":[{"Move":{"kind":{"Local":16},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Shared"]}}},{"Move":{"kind":{"Local":17},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}}}],"dest":{"kind":{"Local":15},"ty":{"Literal":"Bool"}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":28,"content":{"Switch":{"If":[{"Move":{"kind":{"Local":15},"ty":{"Literal":"Bool"}}},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":11},"end":{"line":30,"col":37}},"generated_from_span":null},"statements":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":30,"col":36},"end":{"line":30,"col":37}},"generated_from_span":null},"id":16,"content":{"StorageDead":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":36},"end":{"line":30,"col":37}},"generated_from_span":null},"id":17,"content":{"StorageDead":17},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":36},"end":{"line":30,"col":37}},"generated_from_span":null},"id":18,"content":{"StorageDead":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":32,"col":8},"end":{"line":32,"col":9}},"generated_from_span":null},"id":21,"content":{"StorageDead":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":32,"col":8},"end":{"line":32,"col":9}},"generated_from_span":null},"id":22,"content":{"StorageDead":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":33,"col":8},"end":{"line":33,"col":24}},"generated_from_span":null},"id":23,"content":{"StorageLive":19},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":33,"col":8},"end":{"line":33,"col":12}},"generated_from_span":null},"id":24,"content":{"StorageLive":20},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":33,"col":8},"end":{"line":33,"col":12}},"generated_from_span":null},"id":25,"content":{"Assign":[{"kind":{"Local":20},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Mut"]}},{"Ref":[{"kind":{"Local":2},"ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},"TwoPhaseMut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":33,"col":20},"end":{"line":33,"col":23}},"generated_from_span":null},"id":26,"content":{"StorageLive":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":33,"col":20},"end":{"line":33,"col":23}},"generated_from_span":null},"id":27,"content":{"Assign":[{"kind":{"Local":21},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Local":11},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":33,"col":8},"end":{"line":33,"col":24}},"generated_from_span":null},"id":15,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":7}},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null,{"kind":{"TraitImpl":{"id":3,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":4,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":5,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[]}}}}]}}},"args":[{"Move":{"kind":{"Local":20},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Mut"]}}},{"Move":{"kind":{"Local":21},"ty":{"Literal":{"Int":"I32"}}}}],"dest":{"kind":{"Local":19},"ty":{"Literal":"Bool"}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":33,"col":23},"end":{"line":33,"col":24}},"generated_from_span":null},"id":3,"content":{"StorageDead":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":33,"col":23},"end":{"line":33,"col":24}},"generated_from_span":null},"id":4,"content":{"StorageDead":20},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":33,"col":24},"end":{"line":33,"col":25}},"generated_from_span":null},"id":5,"content":{"StorageDead":19},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":8,"content":{"StorageDead":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":9,"content":{"StorageDead":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":10,"content":{"StorageDead":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":11,"content":{"StorageDead":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":12,"content":{"StorageDead":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":28,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":2,"content":{"Continue":0},"comments_before":[]}]}]}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":36},"end":{"line":30,"col":37}},"generated_from_span":null},"id":30,"content":{"StorageDead":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":36},"end":{"line":30,"col":37}},"generated_from_span":null},"id":31,"content":{"StorageDead":17},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":30,"col":36},"end":{"line":30,"col":37}},"generated_from_span":null},"id":32,"content":{"StorageDead":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":31,"col":19},"end":{"line":31,"col":23}},"generated_from_span":null},"id":33,"content":{"Assign":[{"kind":{"Local":0},"ty":{"Literal":"Bool"}},{"Use":{"Const":{"value":{"Literal":{"Bool":true}},"ty":{"Literal":"Bool"}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":32,"col":8},"end":{"line":32,"col":9}},"generated_from_span":null},"id":34,"content":{"StorageDead":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":32,"col":8},"end":{"line":32,"col":9}},"generated_from_span":null},"id":35,"content":{"StorageDead":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":36,"content":{"StorageDead":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":37,"content":{"StorageDead":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":38,"content":{"StorageDead":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":39,"content":{"StorageDead":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":40,"content":{"StorageDead":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":41,"content":{"StorageDead":6},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":42,"content":{"StorageDead":4},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":43,"content":{"StorageDead":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":37,"col":0},"end":{"line":37,"col":1}},"generated_from_span":null},"id":44,"content":{"Drop":[{"kind":{"Local":2},"ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},{"kind":{"TraitImpl":{"id":1,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":3,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}],"const_generics":[],"trait_refs":[]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":37,"col":0},"end":{"line":37,"col":1}},"generated_from_span":null},"id":45,"content":{"StorageDead":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":37,"col":1},"end":{"line":37,"col":1}},"generated_from_span":null},"id":29,"content":"Return","comments_before":[]}]}]],null]}},"comments_before":[]}]}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":79,"content":{"StorageDead":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":80,"content":{"StorageDead":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":81,"content":{"StorageDead":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":82,"content":{"StorageDead":6},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":83,"content":{"StorageDead":4},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":34,"col":4},"end":{"line":34,"col":5}},"generated_from_span":null},"id":84,"content":{"StorageDead":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":36,"col":4},"end":{"line":36,"col":9}},"generated_from_span":null},"id":85,"content":{"Assign":[{"kind":{"Local":0},"ty":{"Literal":"Bool"}},{"Use":{"Const":{"value":{"Literal":{"Bool":false}},"ty":{"Literal":"Bool"}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":37,"col":0},"end":{"line":37,"col":1}},"generated_from_span":null},"id":86,"content":{"Drop":[{"kind":{"Local":2},"ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},{"kind":{"TraitImpl":{"id":1,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":3,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}],"const_generics":[],"trait_refs":[]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":37,"col":0},"end":{"line":37,"col":1}},"generated_from_span":null},"id":87,"content":{"StorageDead":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":37,"col":1},"end":{"line":37,"col":1}},"generated_from_span":null},"id":76,"content":"Return","comments_before":[]}]}}}}},{"def_id":1,"item_meta":{"name":[{"Ident":["zero_sum_checker",0]},{"Ident":["has_zero_sum_pair_brute_force",0]}],"span":{"span":{"file_id":0,"beg":{"line":50,"col":0},"end":{"line":59,"col":1}},"generated_from_span":null},"source_text":"pub fn has_zero_sum_pair_brute_force(numbers: &[i32]) -> bool {\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n            if numbers[i] + numbers[j] == 0 {\n                return true;\n            }\n        }\n    }\n    false\n}","attr_info":{"attributes":[{"DocComment":" Alternative implementation with O(n²) time complexity but O(1) space complexity."},{"DocComment":" "},{"DocComment":" This is a brute force approach that checks all pairs."},{"DocComment":" "},{"DocComment":" # Arguments"},{"DocComment":" "},{"DocComment":" * `numbers` - A slice of integers to check"},{"DocComment":" "},{"DocComment":" # Returns"},{"DocComment":" "},{"DocComment":" * `true` if there are two numbers that sum to zero, `false` otherwise"}],"inline":null,"rename":null,"public":true},"is_local":true,"opacity":"Transparent","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}],"output":{"Literal":"Bool"}},"kind":"TopLevel","is_global_initializer":null,"body":{"Ok":{"Structured":{"span":{"span":{"file_id":0,"beg":{"line":50,"col":0},"end":{"line":59,"col":1}},"generated_from_span":null},"locals":{"arg_count":1,"locals":[{"index":0,"name":null,"ty":{"Literal":"Bool"}},{"index":1,"name":"numbers","ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"index":2,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":3,"name":null,"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":4,"name":null,"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":5,"name":null,"ty":{"Literal":{"UInt":"Usize"}}},{"index":6,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"index":7,"name":"iter","ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":8,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":9,"name":null,"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":10,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"index":11,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"index":12,"name":"i","ty":{"Literal":{"UInt":"Usize"}}},{"index":13,"name":null,"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":14,"name":null,"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":15,"name":null,"ty":{"Literal":{"UInt":"Usize"}}},{"index":16,"name":null,"ty":{"Literal":{"UInt":"Usize"}}},{"index":17,"name":null,"ty":{"Literal":{"UInt":"Usize"}}},{"index":18,"name":null,"ty":{"Literal":{"UInt":"Usize"}}},{"index":19,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"index":20,"name":"iter","ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":21,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":22,"name":null,"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":23,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"index":24,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"index":25,"name":"j","ty":{"Literal":{"UInt":"Usize"}}},{"index":26,"name":null,"ty":{"Literal":"Bool"}},{"index":27,"name":null,"ty":{"Literal":{"Int":"I32"}}},{"index":28,"name":null,"ty":{"Literal":{"Int":"I32"}}},{"index":29,"name":null,"ty":{"Literal":{"UInt":"Usize"}}},{"index":30,"name":null,"ty":{"Literal":{"Int":"I32"}}},{"index":31,"name":null,"ty":{"Literal":{"UInt":"Usize"}}},{"index":32,"name":null,"ty":{"Literal":{"Int":"I32"}}},{"index":33,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"index":34,"name":null,"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"index":35,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"index":36,"name":null,"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}}]},"comments":[],"body":{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":59,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":370,"content":{"StorageLive":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":371,"content":{"StorageLive":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":372,"content":{"StorageLive":13},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":373,"content":{"StorageLive":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":374,"content":{"StorageLive":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":375,"content":{"StorageLive":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":376,"content":{"StorageLive":17},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":377,"content":{"StorageLive":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":378,"content":{"StorageLive":19},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":379,"content":{"StorageLive":20},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":380,"content":{"StorageLive":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":381,"content":{"StorageLive":22},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":382,"content":{"StorageLive":23},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":383,"content":{"StorageLive":24},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":384,"content":{"StorageLive":25},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":385,"content":{"StorageLive":26},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":386,"content":{"StorageLive":27},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":387,"content":{"StorageLive":28},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":388,"content":{"StorageLive":29},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":389,"content":{"StorageLive":30},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":390,"content":{"StorageLive":31},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":391,"content":{"StorageLive":32},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":392,"content":{"StorageLive":33},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":393,"content":{"StorageLive":34},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":394,"content":{"StorageLive":35},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":395,"content":{"StorageLive":36},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":237,"content":{"StorageLive":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":238,"content":{"StorageLive":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":239,"content":{"StorageLive":4},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":16},"end":{"line":51,"col":29}},"generated_from_span":null},"id":240,"content":{"StorageLive":5},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":16},"end":{"line":51,"col":23}},"generated_from_span":null},"id":241,"content":{"StorageLive":6},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":16},"end":{"line":51,"col":23}},"generated_from_span":null},"id":242,"content":{"Assign":[{"kind":{"Local":6},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":1},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},"Deref"]},"ty":{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":16},"end":{"line":51,"col":29}},"generated_from_span":null},"id":236,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":8}},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"args":[{"Move":{"kind":{"Local":6},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}}}],"dest":{"kind":{"Local":5},"ty":{"Literal":{"UInt":"Usize"}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":28},"end":{"line":51,"col":29}},"generated_from_span":null},"id":233,"content":{"StorageDead":6},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":234,"content":{"Assign":[{"kind":{"Local":4},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"Aggregate":[{"Adt":[{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}},null,null]},[{"Const":{"value":{"Literal":{"Scalar":{"Unsigned":["Usize","0"]}}},"ty":{"Literal":{"UInt":"Usize"}}}},{"Move":{"kind":{"Local":5},"ty":{"Literal":{"UInt":"Usize"}}}}]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":28},"end":{"line":51,"col":29}},"generated_from_span":null},"id":235,"content":{"StorageDead":5},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":232,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":55}},"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null,{"kind":{"TraitImpl":{"id":8,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null,{"kind":{"TraitImpl":{"id":9,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}}}}]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}}}}]}}},"args":[{"Move":{"kind":{"Local":4},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}}}],"dest":{"kind":{"Local":3},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":28},"end":{"line":51,"col":29}},"generated_from_span":null},"id":229,"content":{"StorageDead":4},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":230,"content":{"StorageLive":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":231,"content":{"Assign":[{"kind":{"Local":7},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"Use":{"Move":{"kind":{"Local":3},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":59,"col":1}},"generated_from_span":null},"id":218,"content":{"Loop":{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":59,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":212,"content":{"StorageLive":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":213,"content":{"StorageLive":9},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":214,"content":{"StorageLive":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":215,"content":{"StorageLive":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":216,"content":{"Assign":[{"kind":{"Local":11},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"Ref":[{"kind":{"Local":7},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},"Mut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":217,"content":{"Assign":[{"kind":{"Local":10},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":11},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},"Deref"]},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},"TwoPhaseMut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":211,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":40}},"generics":{"regions":["Erased"],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null,{"kind":{"TraitImpl":{"id":9,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}}}}]}}},"args":[{"Move":{"kind":{"Local":10},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}}}],"dest":{"kind":{"Local":9},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":28},"end":{"line":51,"col":29}},"generated_from_span":null},"id":209,"content":{"StorageDead":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":59,"col":1}},"generated_from_span":null},"id":208,"content":{"Switch":{"Match":[{"kind":{"Local":9},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},[[[0],{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":51,"col":13},"end":{"line":51,"col":29}},"generated_from_span":null},"id":98,"content":{"Break":0},"comments_before":[]}]}],[[1],{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":59,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":51,"col":8},"end":{"line":51,"col":9}},"generated_from_span":null},"id":193,"content":{"StorageLive":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":8},"end":{"line":51,"col":9}},"generated_from_span":null},"id":194,"content":{"Assign":[{"kind":{"Local":12},"ty":{"Literal":{"UInt":"Usize"}}},{"Use":{"Copy":{"kind":{"Projection":[{"kind":{"Local":9},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"Field":[{"Adt":[3,1]},0]}]},"ty":{"Literal":{"UInt":"Usize"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":195,"content":{"StorageLive":13},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":196,"content":{"StorageLive":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":24}},"generated_from_span":null},"id":197,"content":{"StorageLive":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":18},"end":{"line":52,"col":19}},"generated_from_span":null},"id":198,"content":{"StorageLive":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":18},"end":{"line":52,"col":19}},"generated_from_span":null},"id":199,"content":{"Assign":[{"kind":{"Local":16},"ty":{"Literal":{"UInt":"Usize"}}},{"Use":{"Copy":{"kind":{"Local":12},"ty":{"Literal":{"UInt":"Usize"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":24}},"generated_from_span":null},"id":200,"content":{"Assign":[{"kind":{"Local":17},"ty":{"Literal":{"UInt":"Usize"}}},{"BinaryOp":[{"Add":"Panic"},{"Copy":{"kind":{"Local":16},"ty":{"Literal":{"UInt":"Usize"}}}},{"Const":{"value":{"Literal":{"Scalar":{"Unsigned":["Usize","1"]}}},"ty":{"Literal":{"UInt":"Usize"}}}}]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":24}},"generated_from_span":null},"id":202,"content":{"Assign":[{"kind":{"Local":15},"ty":{"Literal":{"UInt":"Usize"}}},{"Use":{"Move":{"kind":{"Local":17},"ty":{"Literal":{"UInt":"Usize"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":23},"end":{"line":52,"col":24}},"generated_from_span":null},"id":203,"content":{"StorageDead":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":26},"end":{"line":52,"col":39}},"generated_from_span":null},"id":204,"content":{"StorageLive":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":26},"end":{"line":52,"col":33}},"generated_from_span":null},"id":205,"content":{"StorageLive":19},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":26},"end":{"line":52,"col":33}},"generated_from_span":null},"id":206,"content":{"Assign":[{"kind":{"Local":19},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":1},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},"Deref"]},"ty":{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":26},"end":{"line":52,"col":39}},"generated_from_span":null},"id":192,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":8}},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"args":[{"Move":{"kind":{"Local":19},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}}}],"dest":{"kind":{"Local":18},"ty":{"Literal":{"UInt":"Usize"}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":38},"end":{"line":52,"col":39}},"generated_from_span":null},"id":188,"content":{"StorageDead":19},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":189,"content":{"Assign":[{"kind":{"Local":14},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"Aggregate":[{"Adt":[{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}},null,null]},[{"Move":{"kind":{"Local":15},"ty":{"Literal":{"UInt":"Usize"}}}},{"Move":{"kind":{"Local":18},"ty":{"Literal":{"UInt":"Usize"}}}}]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":38},"end":{"line":52,"col":39}},"generated_from_span":null},"id":190,"content":{"StorageDead":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":38},"end":{"line":52,"col":39}},"generated_from_span":null},"id":191,"content":{"StorageDead":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":187,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":55}},"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null,{"kind":{"TraitImpl":{"id":8,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null,{"kind":{"TraitImpl":{"id":9,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}}}}]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}}}}]}}},"args":[{"Move":{"kind":{"Local":14},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}}}],"dest":{"kind":{"Local":13},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":38},"end":{"line":52,"col":39}},"generated_from_span":null},"id":184,"content":{"StorageDead":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":185,"content":{"StorageLive":20},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":186,"content":{"Assign":[{"kind":{"Local":20},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"Use":{"Move":{"kind":{"Local":13},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":8},"end":{"line":59,"col":1}},"generated_from_span":null},"id":169,"content":{"Loop":{"span":{"span":{"file_id":0,"beg":{"line":52,"col":8},"end":{"line":59,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":163,"content":{"StorageLive":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":164,"content":{"StorageLive":22},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":165,"content":{"StorageLive":23},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":166,"content":{"StorageLive":24},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":167,"content":{"Assign":[{"kind":{"Local":24},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"Ref":[{"kind":{"Local":20},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},"Mut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":168,"content":{"Assign":[{"kind":{"Local":23},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":24},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},"Deref"]},"ty":{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},"TwoPhaseMut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":162,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":40}},"generics":{"regions":["Erased"],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null,{"kind":{"TraitImpl":{"id":9,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}}}}]}}},"args":[{"Move":{"kind":{"Local":23},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}}}],"dest":{"kind":{"Local":22},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":38},"end":{"line":52,"col":39}},"generated_from_span":null},"id":160,"content":{"StorageDead":23},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":8},"end":{"line":59,"col":1}},"generated_from_span":null},"id":159,"content":{"Switch":{"Match":[{"kind":{"Local":22},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},[[[0],{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":52,"col":17},"end":{"line":52,"col":39}},"generated_from_span":null},"id":99,"content":{"Break":0},"comments_before":[]}]}],[[1],{"span":{"span":{"file_id":0,"beg":{"line":52,"col":8},"end":{"line":59,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":52,"col":12},"end":{"line":52,"col":13}},"generated_from_span":null},"id":115,"content":{"StorageLive":25},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":12},"end":{"line":52,"col":13}},"generated_from_span":null},"id":116,"content":{"Assign":[{"kind":{"Local":25},"ty":{"Literal":{"UInt":"Usize"}}},{"Use":{"Copy":{"kind":{"Projection":[{"kind":{"Local":22},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},{"Field":[{"Adt":[3,1]},0]}]},"ty":{"Literal":{"UInt":"Usize"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":43}},"generated_from_span":null},"id":117,"content":{"StorageLive":26},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":38}},"generated_from_span":null},"id":118,"content":{"StorageLive":27},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":25}},"generated_from_span":null},"id":119,"content":{"StorageLive":28},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":23},"end":{"line":53,"col":24}},"generated_from_span":null},"id":120,"content":{"StorageLive":29},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":23},"end":{"line":53,"col":24}},"generated_from_span":null},"id":121,"content":{"Assign":[{"kind":{"Local":29},"ty":{"Literal":{"UInt":"Usize"}}},{"Use":{"Copy":{"kind":{"Local":12},"ty":{"Literal":{"UInt":"Usize"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":25}},"generated_from_span":null},"id":354,"content":{"StorageLive":35},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":25}},"generated_from_span":null},"id":355,"content":{"Assign":[{"kind":{"Local":35},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":1},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},"Deref"]},"ty":{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":25}},"generated_from_span":null},"id":356,"content":{"StorageLive":36},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":25}},"generated_from_span":null},"id":357,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Builtin":{"Index":{"is_array":false,"mutability":"Shared","is_range":false}}}},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"args":[{"Move":{"kind":{"Local":35},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}}},{"Copy":{"kind":{"Local":29},"ty":{"Literal":{"UInt":"Usize"}}}}],"dest":{"kind":{"Local":36},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":25}},"generated_from_span":null},"id":125,"content":{"Assign":[{"kind":{"Local":28},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Projection":[{"kind":{"Local":36},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},"Deref"]},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":28},"end":{"line":53,"col":38}},"generated_from_span":null},"id":126,"content":{"StorageLive":30},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":36},"end":{"line":53,"col":37}},"generated_from_span":null},"id":127,"content":{"StorageLive":31},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":36},"end":{"line":53,"col":37}},"generated_from_span":null},"id":128,"content":{"Assign":[{"kind":{"Local":31},"ty":{"Literal":{"UInt":"Usize"}}},{"Use":{"Copy":{"kind":{"Local":25},"ty":{"Literal":{"UInt":"Usize"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":28},"end":{"line":53,"col":38}},"generated_from_span":null},"id":350,"content":{"StorageLive":33},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":28},"end":{"line":53,"col":38}},"generated_from_span":null},"id":351,"content":{"Assign":[{"kind":{"Local":33},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":1},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},"Deref"]},"ty":{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":28},"end":{"line":53,"col":38}},"generated_from_span":null},"id":352,"content":{"StorageLive":34},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":28},"end":{"line":53,"col":38}},"generated_from_span":null},"id":353,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Builtin":{"Index":{"is_array":false,"mutability":"Shared","is_range":false}}}},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"args":[{"Move":{"kind":{"Local":33},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}}},{"Copy":{"kind":{"Local":31},"ty":{"Literal":{"UInt":"Usize"}}}}],"dest":{"kind":{"Local":34},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":28},"end":{"line":53,"col":38}},"generated_from_span":null},"id":132,"content":{"Assign":[{"kind":{"Local":30},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Projection":[{"kind":{"Local":34},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},"Deref"]},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":38}},"generated_from_span":null},"id":133,"content":{"Assign":[{"kind":{"Local":32},"ty":{"Literal":{"Int":"I32"}}},{"BinaryOp":[{"Add":"Panic"},{"Copy":{"kind":{"Local":28},"ty":{"Literal":{"Int":"I32"}}}},{"Copy":{"kind":{"Local":30},"ty":{"Literal":{"Int":"I32"}}}}]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":38}},"generated_from_span":null},"id":135,"content":{"Assign":[{"kind":{"Local":27},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Move":{"kind":{"Local":32},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":37},"end":{"line":53,"col":38}},"generated_from_span":null},"id":136,"content":{"StorageDead":30},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":37},"end":{"line":53,"col":38}},"generated_from_span":null},"id":137,"content":{"StorageDead":28},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":43}},"generated_from_span":null},"id":138,"content":{"Assign":[{"kind":{"Local":26},"ty":{"Literal":"Bool"}},{"BinaryOp":["Eq",{"Move":{"kind":{"Local":27},"ty":{"Literal":{"Int":"I32"}}}},{"Const":{"value":{"Literal":{"Scalar":{"Signed":["I32","0"]}}},"ty":{"Literal":{"Int":"I32"}}}}]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":114,"content":{"Switch":{"If":[{"Move":{"kind":{"Local":26},"ty":{"Literal":"Bool"}}},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":15},"end":{"line":53,"col":43}},"generated_from_span":null},"statements":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":53,"col":42},"end":{"line":53,"col":43}},"generated_from_span":null},"id":102,"content":{"StorageDead":31},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":42},"end":{"line":53,"col":43}},"generated_from_span":null},"id":103,"content":{"StorageDead":29},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":42},"end":{"line":53,"col":43}},"generated_from_span":null},"id":104,"content":{"StorageDead":27},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":55,"col":12},"end":{"line":55,"col":13}},"generated_from_span":null},"id":107,"content":{"StorageDead":26},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":108,"content":{"StorageDead":25},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":109,"content":{"StorageDead":24},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":110,"content":{"StorageDead":22},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":111,"content":{"StorageDead":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":52,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":101,"content":{"Continue":0},"comments_before":[]}]}]}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":42},"end":{"line":53,"col":43}},"generated_from_span":null},"id":140,"content":{"StorageDead":31},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":42},"end":{"line":53,"col":43}},"generated_from_span":null},"id":141,"content":{"StorageDead":29},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":53,"col":42},"end":{"line":53,"col":43}},"generated_from_span":null},"id":142,"content":{"StorageDead":27},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":54,"col":23},"end":{"line":54,"col":27}},"generated_from_span":null},"id":143,"content":{"Assign":[{"kind":{"Local":0},"ty":{"Literal":"Bool"}},{"Use":{"Const":{"value":{"Literal":{"Bool":true}},"ty":{"Literal":"Bool"}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":55,"col":12},"end":{"line":55,"col":13}},"generated_from_span":null},"id":144,"content":{"StorageDead":26},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":145,"content":{"StorageDead":25},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":146,"content":{"StorageDead":24},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":147,"content":{"StorageDead":22},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":148,"content":{"StorageDead":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":149,"content":{"StorageDead":20},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":150,"content":{"StorageDead":13},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":151,"content":{"StorageDead":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":152,"content":{"StorageDead":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":153,"content":{"StorageDead":9},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":154,"content":{"StorageDead":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":155,"content":{"StorageDead":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":156,"content":{"StorageDead":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":157,"content":{"StorageDead":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":59,"col":1},"end":{"line":59,"col":1}},"generated_from_span":null},"id":139,"content":"Return","comments_before":[]}]}]],null]}},"comments_before":[]}]}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":173,"content":{"StorageDead":24},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":174,"content":{"StorageDead":22},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":175,"content":{"StorageDead":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":176,"content":{"StorageDead":20},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":56,"col":8},"end":{"line":56,"col":9}},"generated_from_span":null},"id":177,"content":{"StorageDead":13},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":178,"content":{"StorageDead":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":179,"content":{"StorageDead":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":180,"content":{"StorageDead":9},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":181,"content":{"StorageDead":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":51,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":170,"content":{"Continue":0},"comments_before":[]}]}]],null]}},"comments_before":[]}]}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":222,"content":{"StorageDead":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":223,"content":{"StorageDead":9},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":224,"content":{"StorageDead":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":225,"content":{"StorageDead":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":226,"content":{"StorageDead":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":57,"col":4},"end":{"line":57,"col":5}},"generated_from_span":null},"id":227,"content":{"StorageDead":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":58,"col":4},"end":{"line":58,"col":9}},"generated_from_span":null},"id":228,"content":{"Assign":[{"kind":{"Local":0},"ty":{"Literal":"Bool"}},{"Use":{"Const":{"value":{"Literal":{"Bool":false}},"ty":{"Literal":"Bool"}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":59,"col":1},"end":{"line":59,"col":1}},"generated_from_span":null},"id":219,"content":"Return","comments_before":[]}]}}}}},{"def_id":2,"item_meta":{"name":[{"Ident":["zero_sum_checker",0]},{"Ident":["find_zero_sum_pair",0]}],"span":{"span":{"file_id":0,"beg":{"line":79,"col":0},"end":{"line":91,"col":1}},"generated_from_span":null},"source_text":"pub fn find_zero_sum_pair(numbers: &[i32]) -> Option<(i32, i32)> {\n    let mut seen = HashSet::new();\n    \n    for &num in numbers {\n        let complement = -num;\n        if seen.contains(&complement) {\n            return Some((complement, num));\n        }\n        seen.insert(num);\n    }\n    \n    None\n}","attr_info":{"attributes":[{"DocComment":" Finds and returns the first pair of numbers that sum to zero."},{"DocComment":" "},{"DocComment":" # Arguments"},{"DocComment":" "},{"DocComment":" * `numbers` - A list of integers to check"},{"DocComment":" "},{"DocComment":" # Returns"},{"DocComment":" "},{"DocComment":" * `Some((a, b))` where a + b = 0, or `None` if no such pair exists"},{"DocComment":" "},{"DocComment":" # Examples"},{"DocComment":" "},{"DocComment":" ```"},{"DocComment":" use zero_sum_checker::find_zero_sum_pair;"},{"DocComment":" "},{"DocComment":" assert_eq!(find_zero_sum_pair(&[1, 2, -1, 4]), Some((1, -1)));"},{"DocComment":" assert_eq!(find_zero_sum_pair(&[1, 2, 3, 4]), None);"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":true,"opacity":"Transparent","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null]}}}},"kind":"TopLevel","is_global_initializer":null,"body":{"Ok":{"Structured":{"span":{"span":{"file_id":0,"beg":{"line":79,"col":0},"end":{"line":91,"col":1}},"generated_from_span":null},"locals":{"arg_count":1,"locals":[{"index":0,"name":null,"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null]}}}},{"index":1,"name":"numbers","ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"index":2,"name":"seen","ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},{"index":3,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":4,"name":null,"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":5,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"index":6,"name":"iter","ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}},{"index":7,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":8,"name":null,"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[null]}}}},{"index":9,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"index":10,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"index":11,"name":"num","ty":{"Literal":{"Int":"I32"}}},{"index":12,"name":"complement","ty":{"Literal":{"Int":"I32"}}},{"index":13,"name":null,"ty":{"Literal":{"Int":"I32"}}},{"index":14,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":15,"name":null,"ty":{"Literal":"Bool"}},{"index":16,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Shared"]}},{"index":17,"name":null,"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"index":18,"name":null,"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"index":19,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"index":20,"name":null,"ty":{"Literal":{"Int":"I32"}}},{"index":21,"name":null,"ty":{"Literal":{"Int":"I32"}}},{"index":22,"name":null,"ty":{"Literal":"Bool"}},{"index":23,"name":null,"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Mut"]}},{"index":24,"name":null,"ty":{"Literal":{"Int":"I32"}}}]},"comments":[],"body":{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":91,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":396,"content":{"StorageLive":9},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":397,"content":{"StorageLive":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":398,"content":{"StorageLive":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":399,"content":{"StorageLive":13},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":400,"content":{"StorageLive":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":401,"content":{"StorageLive":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":402,"content":{"StorageLive":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":403,"content":{"StorageLive":17},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":404,"content":{"StorageLive":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":405,"content":{"StorageLive":19},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":406,"content":{"StorageLive":20},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":407,"content":{"StorageLive":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":408,"content":{"StorageLive":22},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":409,"content":{"StorageLive":23},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":410,"content":{"StorageLive":24},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":8},"end":{"line":80,"col":16}},"generated_from_span":null},"id":349,"content":{"StorageLive":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":80,"col":19},"end":{"line":80,"col":33}},"generated_from_span":null},"id":348,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":3}},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"args":[],"dest":{"kind":{"Local":2},"ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":344,"content":{"StorageLive":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":345,"content":{"StorageLive":4},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":346,"content":{"StorageLive":5},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":347,"content":{"Assign":[{"kind":{"Local":5},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}},{"Use":{"Copy":{"kind":{"Local":1},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":343,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":168}},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"args":[{"Move":{"kind":{"Local":5},"ty":{"Ref":["Erased",{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}}}],"dest":{"kind":{"Local":4},"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":22},"end":{"line":82,"col":23}},"generated_from_span":null},"id":340,"content":{"StorageDead":5},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":341,"content":{"StorageLive":6},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":342,"content":{"Assign":[{"kind":{"Local":6},"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}},{"Use":{"Move":{"kind":{"Local":4},"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":4},"end":{"line":91,"col":1}},"generated_from_span":null},"id":327,"content":{"Loop":{"span":{"span":{"file_id":0,"beg":{"line":82,"col":4},"end":{"line":91,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":321,"content":{"StorageLive":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":322,"content":{"StorageLive":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":323,"content":{"StorageLive":9},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":324,"content":{"StorageLive":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":325,"content":{"Assign":[{"kind":{"Local":10},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"Ref":[{"kind":{"Local":6},"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}},"Mut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":326,"content":{"Assign":[{"kind":{"Local":9},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":10},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}},"Deref"]},"ty":{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}}},"TwoPhaseMut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":320,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":194}},"generics":{"regions":["Erased","Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"args":[{"Move":{"kind":{"Local":9},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}}}],"dest":{"kind":{"Local":8},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[null]}}}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":22},"end":{"line":82,"col":23}},"generated_from_span":null},"id":318,"content":{"StorageDead":9},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":4},"end":{"line":91,"col":1}},"generated_from_span":null},"id":317,"content":{"Switch":{"Match":[{"kind":{"Local":8},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[null]}}}},[[[0],{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":82,"col":16},"end":{"line":82,"col":23}},"generated_from_span":null},"id":243,"content":{"Break":0},"comments_before":[]}]}],[[1],{"span":{"span":{"file_id":0,"beg":{"line":82,"col":4},"end":{"line":91,"col":1}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":82,"col":9},"end":{"line":82,"col":12}},"generated_from_span":null},"id":299,"content":{"StorageLive":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":9},"end":{"line":82,"col":12}},"generated_from_span":null},"id":300,"content":{"Assign":[{"kind":{"Local":11},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Projection":[{"kind":{"Projection":[{"kind":{"Local":8},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}],"const_generics":[],"trait_refs":[null]}}}},{"Field":[{"Adt":[3,1]},0]}]},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},"Deref"]},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":83,"col":12},"end":{"line":83,"col":22}},"generated_from_span":null},"id":301,"content":{"StorageLive":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":83,"col":26},"end":{"line":83,"col":29}},"generated_from_span":null},"id":302,"content":{"StorageLive":13},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":83,"col":26},"end":{"line":83,"col":29}},"generated_from_span":null},"id":303,"content":{"Assign":[{"kind":{"Local":13},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Local":11},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":83,"col":25},"end":{"line":83,"col":29}},"generated_from_span":null},"id":306,"content":{"Assign":[{"kind":{"Local":12},"ty":{"Literal":{"Int":"I32"}}},{"UnaryOp":[{"Neg":"Panic"},{"Move":{"kind":{"Local":13},"ty":{"Literal":{"Int":"I32"}}}}]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":83,"col":28},"end":{"line":83,"col":29}},"generated_from_span":null},"id":307,"content":{"StorageDead":13},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":8},"end":{"line":86,"col":9}},"generated_from_span":null},"id":308,"content":{"StorageLive":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":11},"end":{"line":84,"col":37}},"generated_from_span":null},"id":309,"content":{"StorageLive":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":11},"end":{"line":84,"col":15}},"generated_from_span":null},"id":310,"content":{"StorageLive":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":11},"end":{"line":84,"col":15}},"generated_from_span":null},"id":311,"content":{"Assign":[{"kind":{"Local":16},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Shared"]}},{"Ref":[{"kind":{"Local":2},"ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":25},"end":{"line":84,"col":36}},"generated_from_span":null},"id":312,"content":{"StorageLive":17},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":25},"end":{"line":84,"col":36}},"generated_from_span":null},"id":313,"content":{"StorageLive":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":25},"end":{"line":84,"col":36}},"generated_from_span":null},"id":314,"content":{"Assign":[{"kind":{"Local":18},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"Ref":[{"kind":{"Local":12},"ty":{"Literal":{"Int":"I32"}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":25},"end":{"line":84,"col":36}},"generated_from_span":null},"id":315,"content":{"Assign":[{"kind":{"Local":17},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":18},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},"Deref"]},"ty":{"Literal":{"Int":"I32"}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":11},"end":{"line":84,"col":37}},"generated_from_span":null},"id":298,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":6}},"generics":{"regions":["Erased","Erased"],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null,{"kind":{"TraitImpl":{"id":3,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":4,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":5,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[]}}}},null,{"kind":{"TraitImpl":{"id":6,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":8,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":4,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":3,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}}]}}},"args":[{"Move":{"kind":{"Local":16},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Shared"]}}},{"Move":{"kind":{"Local":17},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}}}],"dest":{"kind":{"Local":15},"ty":{"Literal":"Bool"}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":271,"content":{"Switch":{"If":[{"Move":{"kind":{"Local":15},"ty":{"Literal":"Bool"}}},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":11},"end":{"line":84,"col":37}},"generated_from_span":null},"statements":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"statements":[{"span":{"span":{"file_id":0,"beg":{"line":84,"col":36},"end":{"line":84,"col":37}},"generated_from_span":null},"id":259,"content":{"StorageDead":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":36},"end":{"line":84,"col":37}},"generated_from_span":null},"id":260,"content":{"StorageDead":17},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":36},"end":{"line":84,"col":37}},"generated_from_span":null},"id":261,"content":{"StorageDead":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":86,"col":8},"end":{"line":86,"col":9}},"generated_from_span":null},"id":264,"content":{"StorageDead":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":86,"col":8},"end":{"line":86,"col":9}},"generated_from_span":null},"id":265,"content":{"StorageDead":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":87,"col":8},"end":{"line":87,"col":24}},"generated_from_span":null},"id":266,"content":{"StorageLive":22},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":87,"col":8},"end":{"line":87,"col":12}},"generated_from_span":null},"id":267,"content":{"StorageLive":23},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":87,"col":8},"end":{"line":87,"col":12}},"generated_from_span":null},"id":268,"content":{"Assign":[{"kind":{"Local":23},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Mut"]}},{"Ref":[{"kind":{"Local":2},"ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},"TwoPhaseMut"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":87,"col":20},"end":{"line":87,"col":23}},"generated_from_span":null},"id":269,"content":{"StorageLive":24},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":87,"col":20},"end":{"line":87,"col":23}},"generated_from_span":null},"id":270,"content":{"Assign":[{"kind":{"Local":24},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Local":11},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":87,"col":8},"end":{"line":87,"col":24}},"generated_from_span":null},"id":258,"content":{"Call":{"func":{"Regular":{"func":{"Fun":{"Regular":7}},"generics":{"regions":["Erased"],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null,{"kind":{"TraitImpl":{"id":3,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":4,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":5,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[]}}}}]}}},"args":[{"Move":{"kind":{"Local":23},"ty":{"Ref":["Erased",{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"Mut"]}}},{"Move":{"kind":{"Local":24},"ty":{"Literal":{"Int":"I32"}}}}],"dest":{"kind":{"Local":22},"ty":{"Literal":"Bool"}}}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":87,"col":23},"end":{"line":87,"col":24}},"generated_from_span":null},"id":246,"content":{"StorageDead":24},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":87,"col":23},"end":{"line":87,"col":24}},"generated_from_span":null},"id":247,"content":{"StorageDead":23},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":87,"col":24},"end":{"line":87,"col":25}},"generated_from_span":null},"id":248,"content":{"StorageDead":22},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":251,"content":{"StorageDead":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":252,"content":{"StorageDead":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":253,"content":{"StorageDead":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":254,"content":{"StorageDead":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":255,"content":{"StorageDead":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":82,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":245,"content":{"Continue":0},"comments_before":[]}]}]}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":36},"end":{"line":84,"col":37}},"generated_from_span":null},"id":273,"content":{"StorageDead":18},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":36},"end":{"line":84,"col":37}},"generated_from_span":null},"id":274,"content":{"StorageDead":17},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":84,"col":36},"end":{"line":84,"col":37}},"generated_from_span":null},"id":275,"content":{"StorageDead":16},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":85,"col":24},"end":{"line":85,"col":41}},"generated_from_span":null},"id":276,"content":{"StorageLive":19},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":85,"col":25},"end":{"line":85,"col":35}},"generated_from_span":null},"id":277,"content":{"StorageLive":20},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":85,"col":25},"end":{"line":85,"col":35}},"generated_from_span":null},"id":278,"content":{"Assign":[{"kind":{"Local":20},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Local":12},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":85,"col":37},"end":{"line":85,"col":40}},"generated_from_span":null},"id":279,"content":{"StorageLive":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":85,"col":37},"end":{"line":85,"col":40}},"generated_from_span":null},"id":280,"content":{"Assign":[{"kind":{"Local":21},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Local":11},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":85,"col":24},"end":{"line":85,"col":41}},"generated_from_span":null},"id":281,"content":{"Assign":[{"kind":{"Local":19},"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}},{"Aggregate":[{"Adt":[{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},null,null]},[{"Move":{"kind":{"Local":20},"ty":{"Literal":{"Int":"I32"}}}},{"Move":{"kind":{"Local":21},"ty":{"Literal":{"Int":"I32"}}}}]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":85,"col":40},"end":{"line":85,"col":41}},"generated_from_span":null},"id":282,"content":{"StorageDead":21},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":85,"col":40},"end":{"line":85,"col":41}},"generated_from_span":null},"id":283,"content":{"StorageDead":20},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":85,"col":19},"end":{"line":85,"col":42}},"generated_from_span":null},"id":284,"content":{"Assign":[{"kind":{"Local":0},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null]}}}},{"Aggregate":[{"Adt":[{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null]}},1,null]},[{"Move":{"kind":{"Local":19},"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}}}]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":85,"col":41},"end":{"line":85,"col":42}},"generated_from_span":null},"id":285,"content":{"StorageDead":19},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":86,"col":8},"end":{"line":86,"col":9}},"generated_from_span":null},"id":286,"content":{"StorageDead":15},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":86,"col":8},"end":{"line":86,"col":9}},"generated_from_span":null},"id":287,"content":{"StorageDead":14},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":288,"content":{"StorageDead":12},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":289,"content":{"StorageDead":11},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":290,"content":{"StorageDead":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":291,"content":{"StorageDead":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":292,"content":{"StorageDead":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":293,"content":{"StorageDead":6},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":294,"content":{"StorageDead":4},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":295,"content":{"StorageDead":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":91,"col":0},"end":{"line":91,"col":1}},"generated_from_span":null},"id":296,"content":{"Drop":[{"kind":{"Local":2},"ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},{"kind":{"TraitImpl":{"id":1,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":3,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}],"const_generics":[],"trait_refs":[]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":91,"col":0},"end":{"line":91,"col":1}},"generated_from_span":null},"id":297,"content":{"StorageDead":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":91,"col":1},"end":{"line":91,"col":1}},"generated_from_span":null},"id":272,"content":"Return","comments_before":[]}]}]],null]}},"comments_before":[]}]}},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":331,"content":{"StorageDead":10},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":332,"content":{"StorageDead":8},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":333,"content":{"StorageDead":7},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":334,"content":{"StorageDead":6},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":335,"content":{"StorageDead":4},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":88,"col":4},"end":{"line":88,"col":5}},"generated_from_span":null},"id":336,"content":{"StorageDead":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":90,"col":4},"end":{"line":90,"col":8}},"generated_from_span":null},"id":337,"content":{"Assign":[{"kind":{"Local":0},"ty":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null]}}}},{"Aggregate":[{"Adt":[{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null]}},0,null]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":91,"col":0},"end":{"line":91,"col":1}},"generated_from_span":null},"id":338,"content":{"Drop":[{"kind":{"Local":2},"ty":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},{"kind":{"TraitImpl":{"id":1,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":3,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}],"const_generics":[],"trait_refs":[]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":91,"col":0},"end":{"line":91,"col":1}},"generated_from_span":null},"id":339,"content":{"StorageDead":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":91,"col":1},"end":{"line":91,"col":1}},"generated_from_span":null},"id":328,"content":"Return","comments_before":[]}]}}}}},{"def_id":3,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["collections",0]},{"Ident":["hash",0]},{"Ident":["set",0]},{"Impl":{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}},"kind":"InherentImplBlock"}}},{"Ident":["new",0]}],"span":{"span":{"file_id":1,"beg":{"line":144,"col":4},"end":{"line":144,"col":43}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Creates an empty `HashSet`."},{"DocComment":""},{"DocComment":" The hash set is initially created with a capacity of 0, so it will not allocate until it"},{"DocComment":" is first inserted into."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::collections::HashSet;"},{"DocComment":" let set: HashSet<i32> = HashSet::new();"},{"DocComment":" ```"}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[],"output":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null]}}}},"kind":"TopLevel","is_global_initializer":null,"body":{"Err":null}},{"def_id":4,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["IntoIterator",0]},{"Ident":["into_iter",0]}],"span":{"span":{"file_id":12,"beg":{"line":310,"col":4},"end":{"line":310,"col":41}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Creates an iterator from a value."},{"DocComment":""},{"DocComment":" See the [module-level documentation] for more."},{"DocComment":""},{"DocComment":" [module-level documentation]: crate::iter"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let v = [1, 2, 3];"},{"DocComment":" let mut iter = v.into_iter();"},{"DocComment":""},{"DocComment":" assert_eq!(Some(1), iter.next());"},{"DocComment":" assert_eq!(Some(2), iter.next());"},{"DocComment":" assert_eq!(Some(3), iter.next());"},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"into_iter"},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Clause0_Item"},{"index":2,"name":"Clause0_IntoIter"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}}],"output":{"TypeVar":{"Free":2}}},"kind":{"TraitDecl":{"trait_ref":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}},"item_name":"into_iter","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":5,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]},{"Ident":["next",0]}],"span":{"span":{"file_id":17,"beg":{"line":75,"col":4},"end":{"line":75,"col":45}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Advances the iterator and returns the next value."},{"DocComment":""},{"DocComment":" Returns [`None`] when iteration is finished. Individual iterator"},{"DocComment":" implementations may choose to resume iteration, and so calling `next()`"},{"DocComment":" again may or may not eventually start returning [`Some(Item)`] again at some"},{"DocComment":" point."},{"DocComment":""},{"DocComment":" [`Some(Item)`]: Some"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let a = [1, 2, 3];"},{"DocComment":""},{"DocComment":" let mut iter = a.into_iter();"},{"DocComment":""},{"DocComment":" // A call to next() returns the next value..."},{"DocComment":" assert_eq!(Some(1), iter.next());"},{"DocComment":" assert_eq!(Some(2), iter.next());"},{"DocComment":" assert_eq!(Some(3), iter.next());"},{"DocComment":""},{"DocComment":" // ... and then None once it's over."},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":""},{"DocComment":" // More calls may or may not return `None`. Here, they always will."},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"next"},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Clause0_Item"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Mut"]}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"next","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":6,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["collections",0]},{"Ident":["hash",0]},{"Ident":["set",0]},{"Impl":{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"},{"index":1,"name":"S"},{"index":2,"name":"Clause4_Hasher"}],"const_generics":[],"trait_clauses":[null,null,{"clause_id":2,"span":{"span":{"file_id":1,"beg":{"line":447,"col":7},"end":{"line":447,"col":9}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":3,"span":{"span":{"file_id":1,"beg":{"line":447,"col":12},"end":{"line":447,"col":16}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":4,"span":{"span":{"file_id":1,"beg":{"line":448,"col":7},"end":{"line":448,"col":18}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,1]}},{"TypeVar":{"Bound":[1,2]}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}},{"TypeVar":{"Bound":[0,1]}}],"const_generics":[],"trait_refs":[null,null]}}},"kind":"InherentImplBlock"}}},{"Ident":["contains",0]}],"span":{"span":{"file_id":1,"beg":{"line":688,"col":4},"end":{"line":691,"col":21}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns `true` if the set contains a value."},{"DocComment":""},{"DocComment":" The value may be any borrowed form of the set's value type, but"},{"DocComment":" [`Hash`] and [`Eq`] on the borrowed form *must* match those for"},{"DocComment":" the value type."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::collections::HashSet;"},{"DocComment":""},{"DocComment":" let set = HashSet::from([1, 2, 3]);"},{"DocComment":" assert_eq!(set.contains(&1), true);"},{"DocComment":" assert_eq!(set.contains(&4), false);"},{"DocComment":" ```"}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"T"},{"index":1,"name":"S"},{"index":2,"name":"Q"},{"index":3,"name":"Clause4_Hasher"}],"const_generics":[],"trait_clauses":[null,null,{"clause_id":2,"span":{"span":{"file_id":1,"beg":{"line":447,"col":7},"end":{"line":447,"col":9}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":3,"span":{"span":{"file_id":1,"beg":{"line":447,"col":12},"end":{"line":447,"col":16}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":4,"span":{"span":{"file_id":1,"beg":{"line":448,"col":7},"end":{"line":448,"col":18}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}},{"TypeVar":{"Free":3}}],"const_generics":[],"trait_refs":[]}}}},null,{"clause_id":6,"span":{"span":{"file_id":1,"beg":{"line":690,"col":11},"end":{"line":690,"col":20}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":8,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":7,"span":{"span":{"file_id":1,"beg":{"line":691,"col":11},"end":{"line":691,"col":15}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":8,"span":{"span":{"file_id":1,"beg":{"line":691,"col":18},"end":{"line":691,"col":20}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null,null]}}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":2}},"Shared"]}],"output":{"Literal":"Bool"}},"kind":"TopLevel","is_global_initializer":null,"body":{"Err":null}},{"def_id":7,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["collections",0]},{"Ident":["hash",0]},{"Ident":["set",0]},{"Impl":{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"},{"index":1,"name":"S"},{"index":2,"name":"Clause4_Hasher"}],"const_generics":[],"trait_clauses":[null,null,{"clause_id":2,"span":{"span":{"file_id":1,"beg":{"line":447,"col":7},"end":{"line":447,"col":9}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":3,"span":{"span":{"file_id":1,"beg":{"line":447,"col":12},"end":{"line":447,"col":16}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":4,"span":{"span":{"file_id":1,"beg":{"line":448,"col":7},"end":{"line":448,"col":18}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,1]}},{"TypeVar":{"Bound":[1,2]}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}},{"TypeVar":{"Bound":[0,1]}}],"const_generics":[],"trait_refs":[null,null]}}},"kind":"InherentImplBlock"}}},{"Ident":["insert",0]}],"span":{"span":{"file_id":1,"beg":{"line":916,"col":4},"end":{"line":916,"col":46}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Adds a value to the set."},{"DocComment":""},{"DocComment":" Returns whether the value was newly inserted. That is:"},{"DocComment":""},{"DocComment":" - If the set did not previously contain this value, `true` is returned."},{"DocComment":" - If the set already contained this value, `false` is returned,"},{"DocComment":"   and the set is not modified: original value is not replaced,"},{"DocComment":"   and the value passed as argument is dropped."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::collections::HashSet;"},{"DocComment":""},{"DocComment":" let mut set = HashSet::new();"},{"DocComment":""},{"DocComment":" assert_eq!(set.insert(2), true);"},{"DocComment":" assert_eq!(set.insert(2), false);"},{"DocComment":" assert_eq!(set.len(), 1);"},{"DocComment":" ```"}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"T"},{"index":1,"name":"S"},{"index":2,"name":"Clause4_Hasher"}],"const_generics":[],"trait_clauses":[null,null,{"clause_id":2,"span":{"span":{"file_id":1,"beg":{"line":447,"col":7},"end":{"line":447,"col":9}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":3,"span":{"span":{"file_id":1,"beg":{"line":447,"col":12},"end":{"line":447,"col":16}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":4,"span":{"span":{"file_id":1,"beg":{"line":448,"col":7},"end":{"line":448,"col":18}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null,null]}}},"Mut"]},{"TypeVar":{"Free":0}}],"output":{"Literal":"Bool"}},"kind":"TopLevel","is_global_initializer":null,"body":{"Err":null}},{"def_id":8,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Impl":{"Ty":{"params":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[]}}},"kind":"InherentImplBlock"}}},{"Ident":["len",0]}],"span":{"span":{"file_id":10,"beg":{"line":116,"col":4},"end":{"line":116,"col":36}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns the number of elements in the slice."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let a = [1, 2, 3];"},{"DocComment":" assert_eq!(a.len(), 3);"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_no_implicit_autorefs","args":null}}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"slice_len_fn"},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}],"output":{"Literal":{"UInt":"Usize"}}},"kind":"TopLevel","is_global_initializer":null,"body":{"Err":null}},null,{"def_id":10,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":5}},{"Ident":["build_hasher",0]}],"span":{"span":{"file_id":5,"beg":{"line":85,"col":4},"end":{"line":85,"col":43}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"Shared"]}],"output":{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":5,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":7,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[]}},"item_name":"build_hasher","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":11,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["BuildHasher",0]},{"Ident":["build_hasher",0]}],"span":{"span":{"file_id":20,"beg":{"line":656,"col":4},"end":{"line":656,"col":43}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Creates a new hasher."},{"DocComment":""},{"DocComment":" Each call to `build_hasher` on the same instance should produce identical"},{"DocComment":" [`Hasher`]s."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::hash::{BuildHasher, RandomState};"},{"DocComment":""},{"DocComment":" let s = RandomState::new();"},{"DocComment":" let new_s = s.build_hasher();"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Clause0_Hasher"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"TypeVar":{"Free":1}}},"kind":{"TraitDecl":{"trait_ref":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"build_hasher","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":12,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":10}},{"Ident":["finish",0]}],"span":{"span":{"file_id":5,"beg":{"line":142,"col":4},"end":{"line":142,"col":27}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"Shared"]}],"output":{"Literal":{"UInt":"U64"}}},"kind":{"TraitImpl":{"impl_ref":{"id":10,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":10,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[]}},"item_name":"finish","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":13,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":10}},{"Ident":["write",0]}],"span":{"span":{"file_id":5,"beg":{"line":132,"col":4},"end":{"line":132,"col":35}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"Mut"]},{"Ref":[{"Var":{"Free":1}},{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"UInt":"U8"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":10,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":10,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[]}},"item_name":"write","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,{"def_id":15,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["write",0]}],"span":{"span":{"file_id":20,"beg":{"line":358,"col":4},"end":{"line":358,"col":38}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Writes some data into this `Hasher`."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::hash::{DefaultHasher, Hasher};"},{"DocComment":""},{"DocComment":" let mut hasher = DefaultHasher::new();"},{"DocComment":" let data = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];"},{"DocComment":""},{"DocComment":" hasher.write(&data);"},{"DocComment":""},{"DocComment":" println!(\"Hash is {:x}!\", hasher.finish());"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" # Note to Implementers"},{"DocComment":""},{"DocComment":" You generally should not do length-prefixing as part of implementing"},{"DocComment":" this method.  It's up to the [`Hash`] implementation to call"},{"DocComment":" [`Hasher::write_length_prefix`] before sequences that need it."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Mut"]},{"Ref":[{"Var":{"Free":1}},{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"Literal":{"UInt":"U8"}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"write","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":16,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]},{"Ident":["finish",0]}],"span":{"span":{"file_id":20,"beg":{"line":335,"col":4},"end":{"line":335,"col":28}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns the hash value for the values written so far."},{"DocComment":""},{"DocComment":" Despite its name, the method does not reset the hasher’s internal"},{"DocComment":" state. Additional [`write`]s will continue from the current value."},{"DocComment":" If you need to start a fresh hash value, you will have to create"},{"DocComment":" a new hasher."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::hash::{DefaultHasher, Hasher};"},{"DocComment":""},{"DocComment":" let mut hasher = DefaultHasher::new();"},{"DocComment":" hasher.write(b\"Cool!\");"},{"DocComment":""},{"DocComment":" println!(\"Hash is {:x}!\", hasher.finish());"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`write`]: Hasher::write"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"Literal":{"UInt":"U64"}}},"kind":{"TraitDecl":{"trait_ref":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"finish","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":17,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["borrow",0]},{"Ident":["Borrow",0]},{"Ident":["borrow",0]}],"span":{"span":{"file_id":21,"beg":{"line":178,"col":4},"end":{"line":178,"col":34}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Immutably borrows from an owned value."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::borrow::Borrow;"},{"DocComment":""},{"DocComment":" fn check<T: Borrow<str>>(s: T) {"},{"DocComment":"     assert_eq!(\"Hello\", s.borrow());"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let s = \"Hello\".to_string();"},{"DocComment":""},{"DocComment":" check(s);"},{"DocComment":""},{"DocComment":" let s = \"Hello\";"},{"DocComment":""},{"DocComment":" check(s);"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Borrowed"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":8,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":1}},"Shared"]}},"kind":{"TraitDecl":{"trait_ref":{"id":8,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"borrow","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":18,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["borrow",0]},{"Impl":{"Trait":6}},{"Ident":["borrow",0]}],"span":{"span":{"file_id":21,"beg":{"line":211,"col":4},"end":{"line":211,"col":26}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"Unknown":{"path":"rustc_diagnostic_item","args":"\"noop_method_borrow\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"noop_method_borrow"},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}},"kind":{"TraitImpl":{"impl_ref":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}},"trait_ref":{"id":8,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"borrow","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,{"def_id":20,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]},{"Ident":["eq",0]}],"span":{"span":{"file_id":19,"beg":{"line":257,"col":4},"end":{"line":257,"col":38}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Tests for `self` and `other` values to be equal, and is used by `==`."},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"cmp_partialeq_eq\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"cmp_partialeq_eq"},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Rhs"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":11,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":1}},"Shared"]}],"output":{"Literal":"Bool"}},"kind":{"TraitDecl":{"trait_ref":{"id":11,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"eq","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,{"def_id":22,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]},{"Ident":["steps_between",0]}],"span":{"span":{"file_id":23,"beg":{"line":40,"col":4},"end":{"line":40,"col":73}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns the bounds on the number of *successor* steps required to get from `start` to `end`"},{"DocComment":" like [`Iterator::size_hint()`][Iterator::size_hint()]."},{"DocComment":""},{"DocComment":" Returns `(usize::MAX, None)` if the number of steps would overflow `usize`, or is infinite."},{"DocComment":""},{"DocComment":" # Invariants"},{"DocComment":""},{"DocComment":" For any `a`, `b`, and `n`:"},{"DocComment":""},{"DocComment":" * `steps_between(&a, &b) == (n, Some(n))` if and only if `Step::forward_checked(&a, n) == Some(b)`"},{"DocComment":" * `steps_between(&a, &b) == (n, Some(n))` if and only if `Step::backward_checked(&b, n) == Some(a)`"},{"DocComment":" * `steps_between(&a, &b) == (n, Some(n))` only if `a <= b`"},{"DocComment":"   * Corollary: `steps_between(&a, &b) == (0, Some(0))` if and only if `a == b`"},{"DocComment":" * `steps_between(&a, &b) == (0, None)` if `a > b`"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}},{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"steps_between","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":23,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]},{"Ident":["forward_checked",0]}],"span":{"span":{"file_id":23,"beg":{"line":58,"col":4},"end":{"line":58,"col":66}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns the value that would be obtained by taking the *successor*"},{"DocComment":" of `self` `count` times."},{"DocComment":""},{"DocComment":" If this would overflow the range of values supported by `Self`, returns `None`."},{"DocComment":""},{"DocComment":" # Invariants"},{"DocComment":""},{"DocComment":" For any `a`, `n`, and `m`:"},{"DocComment":""},{"DocComment":" * `Step::forward_checked(a, n).and_then(|x| Step::forward_checked(x, m)) == Step::forward_checked(a, m).and_then(|x| Step::forward_checked(x, n))`"},{"DocComment":" * `Step::forward_checked(a, n).and_then(|x| Step::forward_checked(x, m)) == try { Step::forward_checked(a, n.checked_add(m)) }`"},{"DocComment":""},{"DocComment":" For any `a` and `n`:"},{"DocComment":""},{"DocComment":" * `Step::forward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::forward_checked(&x, 1))`"},{"DocComment":"   * Corollary: `Step::forward_checked(a, 0) == Some(a)`"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}},{"Literal":{"UInt":"Usize"}}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"forward_checked","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,{"def_id":26,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]},{"Ident":["backward_checked",0]}],"span":{"span":{"file_id":23,"beg":{"line":128,"col":4},"end":{"line":128,"col":67}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns the value that would be obtained by taking the *predecessor*"},{"DocComment":" of `self` `count` times."},{"DocComment":""},{"DocComment":" If this would overflow the range of values supported by `Self`, returns `None`."},{"DocComment":""},{"DocComment":" # Invariants"},{"DocComment":""},{"DocComment":" For any `a`, `n`, and `m`:"},{"DocComment":""},{"DocComment":" * `Step::backward_checked(a, n).and_then(|x| Step::backward_checked(x, m)) == n.checked_add(m).and_then(|x| Step::backward_checked(a, x))`"},{"DocComment":" * `Step::backward_checked(a, n).and_then(|x| Step::backward_checked(x, m)) == try { Step::backward_checked(a, n.checked_add(m)?) }`"},{"DocComment":""},{"DocComment":" For any `a` and `n`:"},{"DocComment":""},{"DocComment":" * `Step::backward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::backward_checked(x, 1))`"},{"DocComment":"   * Corollary: `Step::backward_checked(a, 0) == Some(a)`"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}},{"Literal":{"UInt":"Usize"}}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"backward_checked","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,{"def_id":29,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]},{"Ident":["clone",0]}],"span":{"span":{"file_id":24,"beg":{"line":204,"col":4},"end":{"line":204,"col":28}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns a duplicate of the value."},{"DocComment":""},{"DocComment":" Note that what \"duplicate\" means varies by type:"},{"DocComment":" - For most types, this creates a deep, independent copy"},{"DocComment":" - For reference types like `&T`, this creates another reference to the same value"},{"DocComment":" - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count"},{"DocComment":"   but still points to the same underlying data"},{"DocComment":""},{"DocComment":" [`Arc`]: ../../std/sync/struct.Arc.html"},{"DocComment":" [`Rc`]: ../../std/rc/struct.Rc.html"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(noop_method_call)]"},{"DocComment":" let hello = \"Hello\"; // &str implements Clone"},{"DocComment":""},{"DocComment":" assert_eq!(\"Hello\", hello.clone());"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Example with a reference-counted type:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::sync::{Arc, Mutex};"},{"DocComment":""},{"DocComment":" let data = Arc::new(Mutex::new(vec![1, 2, 3]));"},{"DocComment":" let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex"},{"DocComment":""},{"DocComment":" {"},{"DocComment":"     let mut lock = data.lock().unwrap();"},{"DocComment":"     lock.push(4);"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Changes are visible through the clone because they share the same underlying data"},{"DocComment":" assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"clone_fn"},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":12,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"id":12,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"clone","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,{"def_id":31,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]},{"Ident":["partial_cmp",0]}],"span":{"span":{"file_id":19,"beg":{"line":1371,"col":4},"end":{"line":1371,"col":59}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" This method returns an ordering between `self` and `other` values if one exists."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" let result = 1.0.partial_cmp(&2.0);"},{"DocComment":" assert_eq!(result, Some(Ordering::Less));"},{"DocComment":""},{"DocComment":" let result = 1.0.partial_cmp(&1.0);"},{"DocComment":" assert_eq!(result, Some(Ordering::Equal));"},{"DocComment":""},{"DocComment":" let result = 2.0.partial_cmp(&1.0);"},{"DocComment":" assert_eq!(result, Some(Ordering::Greater));"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" When comparison is impossible:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let result = f64::NAN.partial_cmp(&1.0);"},{"DocComment":" assert_eq!(result, None);"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"cmp_partialord_cmp\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"cmp_partialord_cmp"},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Rhs"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":13,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":1}},"Shared"]}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":9},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":13,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"partial_cmp","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,null,null,{"def_id":40,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}},{"Ident":["next",0]}],"span":{"span":{"file_id":23,"beg":{"line":849,"col":4},"end":{"line":849,"col":35}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"A"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":23,"beg":{"line":845,"col":8},"end":{"line":845,"col":12}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":8,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"trait_ref":{"id":4,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"next","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,null,null,null,{"def_id":50,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]},{"Ident":["cmp",0]}],"span":{"span":{"file_id":19,"beg":{"line":978,"col":4},"end":{"line":978,"col":44}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" This method returns an [`Ordering`] between `self` and `other`."},{"DocComment":""},{"DocComment":" By convention, `self.cmp(&other)` returns the ordering matching the expression"},{"DocComment":" `self <operator> other` if true."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" assert_eq!(5.cmp(&10), Ordering::Less);"},{"DocComment":" assert_eq!(10.cmp(&5), Ordering::Greater);"},{"DocComment":" assert_eq!(5.cmp(&5), Ordering::Equal);"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"ord_cmp_method\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"ord_cmp_method"},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":15,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":0}},"Shared"]}],"output":{"Adt":{"id":{"Adt":9},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":15,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"cmp","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,{"def_id":55,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Impl":{"Trait":7}},{"Ident":["into_iter",0]}],"span":{"span":{"file_id":12,"beg":{"line":319,"col":4},"end":{"line":319,"col":27}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"I"},{"index":1,"name":"Clause1_Item"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":12,"beg":{"line":314,"col":8},"end":{"line":314,"col":16}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitImpl":{"impl_ref":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"trait_ref":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"into_iter","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"def_id":132,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["default",0]},{"Ident":["Default",0]},{"Ident":["default",0]}],"span":{"span":{"file_id":29,"beg":{"line":138,"col":4},"end":{"line":138,"col":25}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Returns the \"default value\" for a type."},{"DocComment":""},{"DocComment":" Default values are often some kind of initial value, identity value, or anything else that"},{"DocComment":" may make sense as a default."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Using built-in default values:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let i: i8 = Default::default();"},{"DocComment":" let (x, y): (Option<String>, f64) = Default::default();"},{"DocComment":" let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Making your own:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" enum Kind {"},{"DocComment":"     A,"},{"DocComment":"     B,"},{"DocComment":"     C,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Default for Kind {"},{"DocComment":"     fn default() -> Self { Kind::A }"},{"DocComment":" }"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"default_fn\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"default_fn"},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":23,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"id":23,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"default","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":133,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnMut",0]},{"Ident":["call_mut",0]}],"span":{"span":{"file_id":27,"beg":{"line":166,"col":4},"end":{"line":166,"col":74}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Performs the call operation."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Args"},{"index":2,"name":"Clause0_Clause1_Output"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":17,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Mut"]},{"TypeVar":{"Free":1}}],"output":{"TypeVar":{"Free":2}}},"kind":{"TraitDecl":{"trait_ref":{"id":17,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}},"item_name":"call_mut","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":134,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnOnce",0]},{"Ident":["call_once",0]}],"span":{"span":{"file_id":27,"beg":{"line":250,"col":4},"end":{"line":250,"col":70}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Performs the call operation."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Args"},{"index":2,"name":"Clause0_Output"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":18,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"output":{"TypeVar":{"Free":2}}},"kind":{"TraitDecl":{"trait_ref":{"id":18,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}},"item_name":"call_once","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":135,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]},{"Ident":["from_output",0]}],"span":{"span":{"file_id":28,"beg":{"line":190,"col":4},"end":{"line":190,"col":49}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Constructs the type from its `Output` type."},{"DocComment":""},{"DocComment":" This should be implemented consistently with the `branch` method"},{"DocComment":" such that applying the `?` operator will get back the original value:"},{"DocComment":" `Try::from_output(x).branch() --> ControlFlow::Continue(x)`."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #![feature(try_trait_v2)]"},{"DocComment":" use std::ops::Try;"},{"DocComment":""},{"DocComment":" assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));"},{"DocComment":" assert_eq!(<Option<_> as Try>::from_output(4), Some(4));"},{"DocComment":" assert_eq!("},{"DocComment":"     <std::ops::ControlFlow<String, _> as Try>::from_output(5),"},{"DocComment":"     std::ops::ControlFlow::Continue(5),"},{"DocComment":" );"},{"DocComment":""},{"DocComment":" # fn make_question_mark_work() -> Option<()> {"},{"DocComment":" assert_eq!(Option::from_output(4)?, 4);"},{"DocComment":" # None }"},{"DocComment":" # make_question_mark_work();"},{"DocComment":""},{"DocComment":" // This is used, for example, on the accumulator in `try_fold`:"},{"DocComment":" let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });"},{"DocComment":" assert_eq!(r, Some(4));"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"from_output"},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Clause0_Output"},{"index":2,"name":"Clause0_Residual"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":20,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":1}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"id":20,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}},"item_name":"from_output","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":136,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]},{"Ident":["branch",0]}],"span":{"span":{"file_id":28,"beg":{"line":217,"col":4},"end":{"line":217,"col":65}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Used in `?` to decide whether the operator should produce a value"},{"DocComment":" (because this returned [`ControlFlow::Continue`])"},{"DocComment":" or propagate a value back to the caller"},{"DocComment":" (because this returned [`ControlFlow::Break`])."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #![feature(try_trait_v2)]"},{"DocComment":" use std::ops::{ControlFlow, Try};"},{"DocComment":""},{"DocComment":" assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));"},{"DocComment":" assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));"},{"DocComment":""},{"DocComment":" assert_eq!(Some(3).branch(), ControlFlow::Continue(3));"},{"DocComment":" assert_eq!(None::<String>.branch(), ControlFlow::Break(None));"},{"DocComment":""},{"DocComment":" assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));"},{"DocComment":" assert_eq!("},{"DocComment":"     ControlFlow::<_, String>::Break(3).branch(),"},{"DocComment":"     ControlFlow::Break(ControlFlow::Break(3)),"},{"DocComment":" );"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"branch"},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Clause0_Output"},{"index":2,"name":"Clause0_Residual"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":20,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}}],"output":{"Adt":{"id":{"Adt":11},"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null,null]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":20,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}},"item_name":"branch","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":137,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["FromResidual",0]},{"Ident":["from_residual",0]}],"span":{"span":{"file_id":28,"beg":{"line":330,"col":4},"end":{"line":330,"col":42}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Constructs the type from a compatible `Residual` type."},{"DocComment":""},{"DocComment":" This should be implemented consistently with the `branch` method such"},{"DocComment":" that applying the `?` operator will get back an equivalent residual:"},{"DocComment":" `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`."},{"DocComment":" (The residual is not mandated to be *identical* when interconversion is involved.)"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #![feature(try_trait_v2)]"},{"DocComment":" use std::ops::{ControlFlow, FromResidual};"},{"DocComment":""},{"DocComment":" assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));"},{"DocComment":" assert_eq!(Option::<String>::from_residual(None), None);"},{"DocComment":" assert_eq!("},{"DocComment":"     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),"},{"DocComment":"     ControlFlow::Break(5),"},{"DocComment":" );"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"from_residual"},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"R"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":30,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":1}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"id":30,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"from_residual","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":138,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["FromIterator",0]},{"Ident":["from_iter",0]}],"span":{"span":{"file_id":12,"beg":{"line":152,"col":4},"end":{"line":152,"col":61}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Creates a value from an iterator."},{"DocComment":""},{"DocComment":" See the [module-level documentation] for more."},{"DocComment":""},{"DocComment":" [module-level documentation]: crate::iter"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let five_fives = std::iter::repeat(5).take(5);"},{"DocComment":""},{"DocComment":" let v = Vec::from_iter(five_fives);"},{"DocComment":""},{"DocComment":" assert_eq!(v, vec![5, 5, 5, 5, 5]);"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"from_iter_fn\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"from_iter_fn"},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"},{"index":2,"name":"T"},{"index":3,"name":"Clause2_IntoIter"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":19,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}},null,{"clause_id":2,"span":{"span":{"file_id":12,"beg":{"line":152,"col":20},"end":{"line":152,"col":42}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":3}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[null]},"inputs":[{"TypeVar":{"Free":2}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"id":19,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"from_iter","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":139,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]},{"Ident":["extend",0]}],"span":{"span":{"file_id":12,"beg":{"line":413,"col":4},"end":{"line":413,"col":61}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Extends a collection with the contents of an iterator."},{"DocComment":""},{"DocComment":" As this is the only required method for this trait, the [trait-level] docs"},{"DocComment":" contain more details."},{"DocComment":""},{"DocComment":" [trait-level]: Extend"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // You can extend a String with some chars:"},{"DocComment":" let mut message = String::from(\"abc\");"},{"DocComment":""},{"DocComment":" message.extend(['d', 'e', 'f'].iter());"},{"DocComment":""},{"DocComment":" assert_eq!(\"abcdef\", &message);"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"},{"index":2,"name":"T"},{"index":3,"name":"Clause2_IntoIter"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":22,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}},null,{"clause_id":2,"span":{"span":{"file_id":12,"beg":{"line":413,"col":17},"end":{"line":413,"col":39}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":3}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[null]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Mut"]},{"TypeVar":{"Free":2}}],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":22,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"extend","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,{"def_id":143,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]},{"Ident":["next_back",0]}],"span":{"span":{"file_id":30,"beg":{"line":94,"col":4},"end":{"line":94,"col":50}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Removes and returns an element from the end of the iterator."},{"DocComment":""},{"DocComment":" Returns `None` when there are no more elements."},{"DocComment":""},{"DocComment":" The [trait-level] docs contain more details."},{"DocComment":""},{"DocComment":" [trait-level]: DoubleEndedIterator"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let numbers = vec![1, 2, 3, 4, 5, 6];"},{"DocComment":""},{"DocComment":" let mut iter = numbers.iter();"},{"DocComment":""},{"DocComment":" assert_eq!(Some(&1), iter.next());"},{"DocComment":" assert_eq!(Some(&6), iter.next_back());"},{"DocComment":" assert_eq!(Some(&5), iter.next_back());"},{"DocComment":" assert_eq!(Some(&2), iter.next());"},{"DocComment":" assert_eq!(Some(&3), iter.next());"},{"DocComment":" assert_eq!(Some(&4), iter.next());"},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" assert_eq!(None, iter.next_back());"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" # Remarks"},{"DocComment":""},{"DocComment":" The elements yielded by `DoubleEndedIterator`'s methods may differ from"},{"DocComment":" the ones yielded by [`Iterator`]'s methods:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let vec = vec![(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b')];"},{"DocComment":" let uniq_by_fst_comp = || {"},{"DocComment":"     let mut seen = std::collections::HashSet::new();"},{"DocComment":"     vec.iter().copied().filter(move |x| seen.insert(x.0))"},{"DocComment":" };"},{"DocComment":""},{"DocComment":" assert_eq!(uniq_by_fst_comp().last(), Some((2, 'a')));"},{"DocComment":" assert_eq!(uniq_by_fst_comp().next_back(), Some((2, 'b')));"},{"DocComment":""},{"DocComment":" assert_eq!("},{"DocComment":"     uniq_by_fst_comp().fold(vec![], |mut v, x| {v.push(x); v}),"},{"DocComment":"     vec![(1, 'a'), (2, 'a')]"},{"DocComment":" );"},{"DocComment":" assert_eq!("},{"DocComment":"     uniq_by_fst_comp().rfold(vec![], |mut v, x| {v.push(x); v}),"},{"DocComment":"     vec![(2, 'b'), (1, 'c')]"},{"DocComment":" );"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Clause0_Clause1_Item"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":24,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Mut"]}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":24,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"next_back","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,null,{"def_id":151,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hash",0]},{"Ident":["hash",0]}],"span":{"span":{"file_id":20,"beg":{"line":199,"col":4},"end":{"line":199,"col":45}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Feeds this value into the given [`Hasher`]."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::hash::{DefaultHasher, Hash, Hasher};"},{"DocComment":""},{"DocComment":" let mut hasher = DefaultHasher::new();"},{"DocComment":" 7920.hash(&mut hasher);"},{"DocComment":" println!(\"Hash is {:x}!\", hasher.finish());"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"Self"},{"index":1,"name":"H"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}},null,{"clause_id":2,"span":{"span":{"file_id":20,"beg":{"line":199,"col":15},"end":{"line":199,"col":21}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":1}},"Mut"]}],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"hash","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"def_id":168,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":0}},{"Ident":["into_iter",0]}],"span":{"span":{"file_id":9,"beg":{"line":25,"col":4},"end":{"line":25,"col":37}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":"'a"}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}},"Shared"]}],"output":{"Adt":{"id":{"Adt":2},"generics":{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":0,"generics":{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}},"trait_ref":{"id":2,"generics":{"regions":[],"types":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}},"Shared"]},{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Adt":{"id":{"Adt":2},"generics":{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}}],"const_generics":[],"trait_refs":[]}},"item_name":"into_iter","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":169,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":11}},{"Ident":["eq",0]}],"span":{"span":{"file_id":19,"beg":{"line":1815,"col":16},"end":{"line":1815,"col":50}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Literal":{"Int":"I32"}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"Literal":{"Int":"I32"}},"Shared"]}],"output":{"Literal":"Bool"}},"kind":{"TraitImpl":{"impl_ref":{"id":11,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":11,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}},"item_name":"eq","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,{"def_id":171,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}},{"Ident":["steps_between",0]}],"span":{"span":{"file_id":23,"beg":{"line":263,"col":16},"end":{"line":263,"col":84}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Literal":{"UInt":"Usize"}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"Literal":{"UInt":"Usize"}},"Shared"]}],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}},{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":9,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":9,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}},"item_name":"steps_between","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":172,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}},{"Ident":["forward_checked",0]}],"span":{"span":{"file_id":23,"beg":{"line":274,"col":16},"end":{"line":274,"col":73}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Literal":{"UInt":"Usize"}},{"Literal":{"UInt":"Usize"}}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":9,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":9,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}},"item_name":"forward_checked","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,null,{"def_id":175,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}},{"Ident":["backward_checked",0]}],"span":{"span":{"file_id":23,"beg":{"line":282,"col":16},"end":{"line":282,"col":74}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Literal":{"UInt":"Usize"}},{"Literal":{"UInt":"Usize"}}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":9,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":9,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}},"item_name":"backward_checked","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,null,{"def_id":178,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["impls",0]},{"Impl":{"Trait":12}},{"Ident":["clone",0]}],"span":{"span":{"file_id":24,"beg":{"line":548,"col":20},"end":{"line":548,"col":43}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Always","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Literal":{"UInt":"Usize"}},"Shared"]}],"output":{"Literal":{"UInt":"Usize"}}},"kind":{"TraitImpl":{"impl_ref":{"id":12,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":12,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}},"item_name":"clone","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":179,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}},{"Ident":["partial_cmp",0]}],"span":{"span":{"file_id":19,"beg":{"line":1930,"col":16},"end":{"line":1930,"col":71}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Literal":{"UInt":"Usize"}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"Literal":{"UInt":"Usize"}},"Shared"]}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":9},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":13,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":13,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}},{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}},"item_name":"partial_cmp","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,null,null,{"def_id":188,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":14}},{"Ident":["eq",0]}],"span":{"span":{"file_id":19,"beg":{"line":1815,"col":16},"end":{"line":1815,"col":50}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Literal":{"UInt":"Usize"}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"Literal":{"UInt":"Usize"}},"Shared"]}],"output":{"Literal":"Bool"}},"kind":{"TraitImpl":{"impl_ref":{"id":14,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":11,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}},{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}},"item_name":"eq","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,{"def_id":190,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Sum",0]},{"Ident":["sum",0]}],"span":{"span":{"file_id":32,"beg":{"line":21,"col":4},"end":{"line":21,"col":51}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Takes an iterator and generates `Self` from the elements by \"summing up\""},{"DocComment":" the items."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"},{"index":2,"name":"I"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":27,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}},null,{"clause_id":2,"span":{"span":{"file_id":32,"beg":{"line":21,"col":14},"end":{"line":21,"col":32}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[null]},"inputs":[{"TypeVar":{"Free":2}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"id":27,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"sum","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":191,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Product",0]},{"Ident":["product",0]}],"span":{"span":{"file_id":32,"beg":{"line":42,"col":4},"end":{"line":42,"col":55}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Takes an iterator and generates `Self` from the elements by multiplying"},{"DocComment":" the items."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"},{"index":2,"name":"I"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":28,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}},null,{"clause_id":2,"span":{"span":{"file_id":32,"beg":{"line":42,"col":18},"end":{"line":42,"col":36}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[null]},"inputs":[{"TypeVar":{"Free":2}}],"output":{"TypeVar":{"Free":0}}},"kind":{"TraitDecl":{"trait_ref":{"id":28,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}},"item_name":"product","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},{"def_id":192,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["impls",0]},{"Impl":{"Trait":4}},{"Ident":["hash",0]}],"span":{"span":{"file_id":20,"beg":{"line":811,"col":16},"end":{"line":811,"col":56}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"H"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":20,"beg":{"line":811,"col":27},"end":{"line":811,"col":33}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Literal":{"Int":"I32"}},"Shared"]},{"Ref":[{"Var":{"Free":1}},{"TypeVar":{"Free":0}},"Mut"]}],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":4,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"trait_ref":{"id":6,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}},"item_name":"hash","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,{"def_id":194,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}},{"Ident":["next",0]}],"span":{"span":{"file_id":18,"beg":{"line":156,"col":12},"end":{"line":156,"col":47}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":"'a"},{"index":1,"name":null}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":1}},{"Adt":{"id":{"Adt":2},"generics":{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}},"Mut"]}],"output":{"Adt":{"id":{"Adt":3},"generics":{"regions":[],"types":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"const_generics":[],"trait_refs":[null]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":2,"generics":{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}},"trait_ref":{"id":4,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":2},"generics":{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}},{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"const_generics":[],"trait_refs":[]}},"item_name":"next","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"global_decls":[null,null,null,null,null],"trait_decls":[null,null,{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["IntoIterator",0]}],"span":{"span":{"file_id":12,"beg":{"line":282,"col":0},"end":{"line":282,"col":22}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Conversion into an [`Iterator`]."},{"DocComment":""},{"DocComment":" By implementing `IntoIterator` for a type, you define how it will be"},{"DocComment":" converted to an iterator. This is common for types which describe a"},{"DocComment":" collection of some kind."},{"DocComment":""},{"DocComment":" One benefit of implementing `IntoIterator` is that your type will [work"},{"DocComment":" with Rust's `for` loop syntax](crate::iter#for-loops-and-intoiterator)."},{"DocComment":""},{"DocComment":" See also: [`FromIterator`]."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let v = [1, 2, 3];"},{"DocComment":" let mut iter = v.into_iter();"},{"DocComment":""},{"DocComment":" assert_eq!(Some(1), iter.next());"},{"DocComment":" assert_eq!(Some(2), iter.next());"},{"DocComment":" assert_eq!(Some(3), iter.next());"},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" ```"},{"DocComment":" Implementing `IntoIterator` for your type:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // A sample collection, that's just a wrapper over Vec<T>"},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct MyCollection(Vec<i32>);"},{"DocComment":""},{"DocComment":" // Let's give it some methods so we can create one and add things"},{"DocComment":" // to it."},{"DocComment":" impl MyCollection {"},{"DocComment":"     fn new() -> MyCollection {"},{"DocComment":"         MyCollection(Vec::new())"},{"DocComment":"     }"},{"DocComment":""},{"DocComment":"     fn add(&mut self, elem: i32) {"},{"DocComment":"         self.0.push(elem);"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // and we'll implement IntoIterator"},{"DocComment":" impl IntoIterator for MyCollection {"},{"DocComment":"     type Item = i32;"},{"DocComment":"     type IntoIter = std::vec::IntoIter<Self::Item>;"},{"DocComment":""},{"DocComment":"     fn into_iter(self) -> Self::IntoIter {"},{"DocComment":"         self.0.into_iter()"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Now we can make a new collection..."},{"DocComment":" let mut c = MyCollection::new();"},{"DocComment":""},{"DocComment":" // ... add some stuff to it ..."},{"DocComment":" c.add(0);"},{"DocComment":" c.add(1);"},{"DocComment":" c.add(2);"},{"DocComment":""},{"DocComment":" // ... and then turn it into an Iterator:"},{"DocComment":" for (i, n) in c.into_iter().enumerate() {"},{"DocComment":"     assert_eq!(i as i32, n);"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" It is common to use `IntoIterator` as a trait bound. This allows"},{"DocComment":" the input collection type to change, so long as it is still an"},{"DocComment":" iterator. Additional bounds can be specified by restricting on"},{"DocComment":" `Item`:"},{"DocComment":""},{"DocComment":" ```rust"},{"DocComment":" fn collect_as_strings<T>(collection: T) -> Vec<String>"},{"DocComment":" where"},{"DocComment":"     T: IntoIterator,"},{"DocComment":"     T::Item: std::fmt::Debug,"},{"DocComment":" {"},{"DocComment":"     collection"},{"DocComment":"         .into_iter()"},{"DocComment":"         .map(|item| format!(\"{item:?}\"))"},{"DocComment":"         .collect()"},{"DocComment":" }"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"IntoIterator\""}},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(Self = \"core::ops::range::RangeTo<Idx>\", label =\n\"if you meant to iterate until a value, add a starting value\", note =\n\"`..end` is a `RangeTo`, which cannot be iterated on; you might have meant to have a \\\n              bounded `Range`: `0..end`\"),\non(Self = \"core::ops::range::RangeToInclusive<Idx>\", label =\n\"if you meant to iterate until a value (including it), add a starting value\",\nnote =\n\"`..=end` is a `RangeToInclusive`, which cannot be iterated on; you might have meant \\\n              to have a bounded `RangeInclusive`: `0..=end`\"),\non(Self = \"[]\", label =\n\"`{Self}` is not an iterator; try calling `.into_iter()` or `.iter()`\"),\non(Self = \"&[]\", label =\n\"`{Self}` is not an iterator; try calling `.iter()`\"),\non(Self = \"alloc::vec::Vec<T, A>\", label =\n\"`{Self}` is not an iterator; try calling `.into_iter()` or `.iter()`\"),\non(Self = \"&str\", label =\n\"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"),\non(Self = \"alloc::string::String\", label =\n\"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"),\non(Self = \"{integral}\", note =\n\"if you want to iterate between `start` until a value `end`, use the exclusive range \\\n              syntax `start..end` or the inclusive range syntax `start..=end`\"),\non(Self = \"{float}\", note =\n\"if you want to iterate between `start` until a value `end`, use the exclusive range \\\n              syntax `start..end` or the inclusive range syntax `start..=end`\"),\nlabel = \"`{Self}` is not an iterator\", message = \"`{Self}` is not an iterator\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"IntoIterator"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Self_Item"},{"index":2,"name":"Self_IntoIter"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[null]},"parent_clauses":[null,null,null,{"clause_id":3,"span":{"span":{"file_id":12,"beg":{"line":289,"col":19},"end":{"line":289,"col":46}},"generated_from_span":null},"origin":{"TraitItem":"IntoIter"},"trait_":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["into_iter",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[2,"into_iter"]}}]],"vtable":null},null,{"def_id":4,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["iterator",0]},{"Ident":["Iterator",0]}],"span":{"span":{"file_id":17,"beg":{"line":39,"col":0},"end":{"line":39,"col":18}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A trait for dealing with iterators."},{"DocComment":""},{"DocComment":" This is the main iterator trait. For more about the concept of iterators"},{"DocComment":" generally, please see the [module-level documentation]. In particular, you"},{"DocComment":" may want to know how to [implement `Iterator`][impl]."},{"DocComment":""},{"DocComment":" [module-level documentation]: crate::iter"},{"DocComment":" [impl]: crate::iter#implementing-iterator"},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(Self = \"core::ops::range::RangeTo<Idx>\", note =\n\"you might have meant to use a bounded `Range`\"),\non(Self = \"core::ops::range::RangeToInclusive<Idx>\", note =\n\"you might have meant to use a bounded `RangeInclusive`\"), label =\n\"`{Self}` is not an iterator\", message = \"`{Self}` is not an iterator\""}},{"Unknown":{"path":"doc","args":"notable_trait"}},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"Iterator\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"iterator"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Self_Item"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["next",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":5,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[4,"next"]}}]],"vtable":null},{"def_id":5,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Eq",0]}],"span":{"span":{"file_id":19,"beg":{"line":338,"col":0},"end":{"line":338,"col":44}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait for comparisons corresponding to [equivalence relations]("},{"DocComment":" https://en.wikipedia.org/wiki/Equivalence_relation)."},{"DocComment":""},{"DocComment":" The primary difference to [`PartialEq`] is the additional requirement for reflexivity. A type"},{"DocComment":" that implements [`PartialEq`] guarantees that for all `a`, `b` and `c`:"},{"DocComment":""},{"DocComment":" - symmetric: `a == b` implies `b == a` and `a != b` implies `!(a == b)`"},{"DocComment":" - transitive: `a == b` and `b == c` implies `a == c`"},{"DocComment":""},{"DocComment":" `Eq`, which builds on top of [`PartialEq`] also implies:"},{"DocComment":""},{"DocComment":" - reflexive: `a == a`"},{"DocComment":""},{"DocComment":" This property cannot be checked by the compiler, and therefore `Eq` is a trait without methods."},{"DocComment":""},{"DocComment":" Violating this property is a logic error. The behavior resulting from a logic error is not"},{"DocComment":" specified, but users of the trait must ensure that such logic errors do *not* result in"},{"DocComment":" undefined behavior. This means that `unsafe` code **must not** rely on the correctness of these"},{"DocComment":" methods."},{"DocComment":""},{"DocComment":" Floating point types such as [`f32`] and [`f64`] implement only [`PartialEq`] but *not* `Eq`"},{"DocComment":" because `NaN` != `NaN`."},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]`. When `derive`d, because `Eq` has no extra methods, it"},{"DocComment":" is only informing the compiler that this is an equivalence relation rather than a partial"},{"DocComment":" equivalence relation. Note that the `derive` strategy requires all fields are `Eq`, which isn't"},{"DocComment":" always desired."},{"DocComment":""},{"DocComment":" ## How can I implement `Eq`?"},{"DocComment":""},{"DocComment":" If you cannot use the `derive` strategy, specify that your type implements `Eq`, which has no"},{"DocComment":" extra methods:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" enum BookFormat {"},{"DocComment":"     Paperback,"},{"DocComment":"     Hardback,"},{"DocComment":"     Ebook,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" struct Book {"},{"DocComment":"     isbn: i32,"},{"DocComment":"     format: BookFormat,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Book {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.isbn == other.isbn"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for Book {}"},{"DocComment":" ```"},{"Unknown":{"path":"doc","args":"alias = \"==\""}},{"Unknown":{"path":"doc","args":"alias = \"!=\""}},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"Eq\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Eq"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":19,"beg":{"line":338,"col":14},"end":{"line":338,"col":29}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":11,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[],"vtable":null},{"def_id":6,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hash",0]}],"span":{"span":{"file_id":20,"beg":{"line":186,"col":0},"end":{"line":186,"col":36}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A hashable type."},{"DocComment":""},{"DocComment":" Types implementing `Hash` are able to be [`hash`]ed with an instance of"},{"DocComment":" [`Hasher`]."},{"DocComment":""},{"DocComment":" ## Implementing `Hash`"},{"DocComment":""},{"DocComment":" You can derive `Hash` with `#[derive(Hash)]` if all fields implement `Hash`."},{"DocComment":" The resulting hash will be the combination of the values from calling"},{"DocComment":" [`hash`] on each field."},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Hash)]"},{"DocComment":" struct Rustacean {"},{"DocComment":"     name: String,"},{"DocComment":"     country: String,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" If you need more control over how a value is hashed, you can of course"},{"DocComment":" implement the `Hash` trait yourself:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::hash::{Hash, Hasher};"},{"DocComment":""},{"DocComment":" struct Person {"},{"DocComment":"     id: u32,"},{"DocComment":"     name: String,"},{"DocComment":"     phone: u64,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Hash for Person {"},{"DocComment":"     fn hash<H: Hasher>(&self, state: &mut H) {"},{"DocComment":"         self.id.hash(state);"},{"DocComment":"         self.phone.hash(state);"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## `Hash` and `Eq`"},{"DocComment":""},{"DocComment":" When implementing both `Hash` and [`Eq`], it is important that the following"},{"DocComment":" property holds:"},{"DocComment":""},{"DocComment":" ```text"},{"DocComment":" k1 == k2 -> hash(k1) == hash(k2)"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" In other words, if two keys are equal, their hashes must also be equal."},{"DocComment":" [`HashMap`] and [`HashSet`] both rely on this behavior."},{"DocComment":""},{"DocComment":" Thankfully, you won't need to worry about upholding this property when"},{"DocComment":" deriving both [`Eq`] and `Hash` with `#[derive(PartialEq, Eq, Hash)]`."},{"DocComment":""},{"DocComment":" Violating this property is a logic error. The behavior resulting from a logic error is not"},{"DocComment":" specified, but users of the trait must ensure that such logic errors do *not* result in"},{"DocComment":" undefined behavior. This means that `unsafe` code **must not** rely on the correctness of these"},{"DocComment":" methods."},{"DocComment":""},{"DocComment":" ## Prefix collisions"},{"DocComment":""},{"DocComment":" Implementations of `hash` should ensure that the data they"},{"DocComment":" pass to the `Hasher` are prefix-free. That is,"},{"DocComment":" values which are not equal should cause two different sequences of values to be written,"},{"DocComment":" and neither of the two sequences should be a prefix of the other."},{"DocComment":""},{"DocComment":" For example, the standard implementation of [`Hash` for `&str`][impl] passes an extra"},{"DocComment":" `0xFF` byte to the `Hasher` so that the values `(\"ab\", \"c\")` and `(\"a\","},{"DocComment":" \"bc\")` hash differently."},{"DocComment":""},{"DocComment":" ## Portability"},{"DocComment":""},{"DocComment":" Due to differences in endianness and type sizes, data fed by `Hash` to a `Hasher`"},{"DocComment":" should not be considered portable across platforms. Additionally the data passed by most"},{"DocComment":" standard library types should not be considered stable between compiler versions."},{"DocComment":""},{"DocComment":" This means tests shouldn't probe hard-coded hash values or data fed to a `Hasher` and"},{"DocComment":" instead should check consistency with `Eq`."},{"DocComment":""},{"DocComment":" Serialization formats intended to be portable between platforms or compiler versions should"},{"DocComment":" either avoid encoding hashes or only rely on `Hash` and `Hasher` implementations that"},{"DocComment":" provide additional guarantees."},{"DocComment":""},{"DocComment":" [`HashMap`]: ../../std/collections/struct.HashMap.html"},{"DocComment":" [`HashSet`]: ../../std/collections/struct.HashSet.html"},{"DocComment":" [`hash`]: Hash::hash"},{"DocComment":" [impl]: ../../std/primitive.str.html#impl-Hash-for-str"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"Hash\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Hash"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["hash",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"H"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":20,"beg":{"line":199,"col":15},"end":{"line":199,"col":21}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":151,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":6,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}},null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[6,"hash"]}}]],"vtable":null},{"def_id":7,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["BuildHasher",0]}],"span":{"span":{"file_id":20,"beg":{"line":637,"col":0},"end":{"line":637,"col":21}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A trait for creating instances of [`Hasher`]."},{"DocComment":""},{"DocComment":" A `BuildHasher` is typically used (e.g., by [`HashMap`]) to create"},{"DocComment":" [`Hasher`]s for each key such that they are hashed independently of one"},{"DocComment":" another, since [`Hasher`]s contain state."},{"DocComment":""},{"DocComment":" For each instance of `BuildHasher`, the [`Hasher`]s created by"},{"DocComment":" [`build_hasher`] should be identical. That is, if the same stream of bytes"},{"DocComment":" is fed into each hasher, the same output will also be generated."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::hash::{BuildHasher, Hasher, RandomState};"},{"DocComment":""},{"DocComment":" let s = RandomState::new();"},{"DocComment":" let mut hasher_1 = s.build_hasher();"},{"DocComment":" let mut hasher_2 = s.build_hasher();"},{"DocComment":""},{"DocComment":" hasher_1.write_u32(8128);"},{"DocComment":" hasher_2.write_u32(8128);"},{"DocComment":""},{"DocComment":" assert_eq!(hasher_1.finish(), hasher_2.finish());"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`build_hasher`]: BuildHasher::build_hasher"},{"DocComment":" [`HashMap`]: ../../std/collections/struct.HashMap.html"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Self_Hasher"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null,{"clause_id":2,"span":{"span":{"file_id":20,"beg":{"line":640,"col":17},"end":{"line":640,"col":23}},"generated_from_span":null},"origin":{"TraitItem":"Hasher"},"trait_":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["build_hasher",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":11,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":7,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[7,"build_hasher"]}}]],"vtable":null},{"def_id":8,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["borrow",0]},{"Ident":["Borrow",0]}],"span":{"span":{"file_id":21,"beg":{"line":157,"col":0},"end":{"line":157,"col":34}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A trait for borrowing data."},{"DocComment":""},{"DocComment":" In Rust, it is common to provide different representations of a type for"},{"DocComment":" different use cases. For instance, storage location and management for a"},{"DocComment":" value can be specifically chosen as appropriate for a particular use via"},{"DocComment":" pointer types such as [`Box<T>`] or [`Rc<T>`]. Beyond these generic"},{"DocComment":" wrappers that can be used with any type, some types provide optional"},{"DocComment":" facets providing potentially costly functionality. An example for such a"},{"DocComment":" type is [`String`] which adds the ability to extend a string to the basic"},{"DocComment":" [`str`]. This requires keeping additional information unnecessary for a"},{"DocComment":" simple, immutable string."},{"DocComment":""},{"DocComment":" These types provide access to the underlying data through references"},{"DocComment":" to the type of that data. They are said to be ‘borrowed as’ that type."},{"DocComment":" For instance, a [`Box<T>`] can be borrowed as `T` while a [`String`]"},{"DocComment":" can be borrowed as `str`."},{"DocComment":""},{"DocComment":" Types express that they can be borrowed as some type `T` by implementing"},{"DocComment":" `Borrow<T>`, providing a reference to a `T` in the trait’s"},{"DocComment":" [`borrow`] method. A type is free to borrow as several different types."},{"DocComment":" If it wishes to mutably borrow as the type, allowing the underlying data"},{"DocComment":" to be modified, it can additionally implement [`BorrowMut<T>`]."},{"DocComment":""},{"DocComment":" Further, when providing implementations for additional traits, it needs"},{"DocComment":" to be considered whether they should behave identically to those of the"},{"DocComment":" underlying type as a consequence of acting as a representation of that"},{"DocComment":" underlying type. Generic code typically uses `Borrow<T>` when it relies"},{"DocComment":" on the identical behavior of these additional trait implementations."},{"DocComment":" These traits will likely appear as additional trait bounds."},{"DocComment":""},{"DocComment":" In particular `Eq`, `Ord` and `Hash` must be equivalent for"},{"DocComment":" borrowed and owned values: `x.borrow() == y.borrow()` should give the"},{"DocComment":" same result as `x == y`."},{"DocComment":""},{"DocComment":" If generic code merely needs to work for all types that can"},{"DocComment":" provide a reference to related type `T`, it is often better to use"},{"DocComment":" [`AsRef<T>`] as more types can safely implement it."},{"DocComment":""},{"DocComment":" [`Box<T>`]: ../../std/boxed/struct.Box.html"},{"DocComment":" [`Mutex<T>`]: ../../std/sync/struct.Mutex.html"},{"DocComment":" [`Rc<T>`]: ../../std/rc/struct.Rc.html"},{"DocComment":" [`String`]: ../../std/string/struct.String.html"},{"DocComment":" [`borrow`]: Borrow::borrow"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" As a data collection, [`HashMap<K, V>`] owns both keys and values. If"},{"DocComment":" the key’s actual data is wrapped in a managing type of some kind, it"},{"DocComment":" should, however, still be possible to search for a value using a"},{"DocComment":" reference to the key’s data. For instance, if the key is a string, then"},{"DocComment":" it is likely stored with the hash map as a [`String`], while it should"},{"DocComment":" be possible to search using a [`&str`][`str`]. Thus, `insert` needs to"},{"DocComment":" operate on a `String` while `get` needs to be able to use a `&str`."},{"DocComment":""},{"DocComment":" Slightly simplified, the relevant parts of `HashMap<K, V>` look like"},{"DocComment":" this:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::borrow::Borrow;"},{"DocComment":" use std::hash::Hash;"},{"DocComment":""},{"DocComment":" pub struct HashMap<K, V> {"},{"DocComment":"     # marker: ::std::marker::PhantomData<(K, V)>,"},{"DocComment":"     // fields omitted"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl<K, V> HashMap<K, V> {"},{"DocComment":"     pub fn insert(&self, key: K, value: V) -> Option<V>"},{"DocComment":"     where K: Hash + Eq"},{"DocComment":"     {"},{"DocComment":"         # unimplemented!()"},{"DocComment":"         // ..."},{"DocComment":"     }"},{"DocComment":""},{"DocComment":"     pub fn get<Q>(&self, k: &Q) -> Option<&V>"},{"DocComment":"     where"},{"DocComment":"         K: Borrow<Q>,"},{"DocComment":"         Q: Hash + Eq + ?Sized"},{"DocComment":"     {"},{"DocComment":"         # unimplemented!()"},{"DocComment":"         // ..."},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The entire hash map is generic over a key type `K`. Because these keys"},{"DocComment":" are stored with the hash map, this type has to own the key’s data."},{"DocComment":" When inserting a key-value pair, the map is given such a `K` and needs"},{"DocComment":" to find the correct hash bucket and check if the key is already present"},{"DocComment":" based on that `K`. It therefore requires `K: Hash + Eq`."},{"DocComment":""},{"DocComment":" When searching for a value in the map, however, having to provide a"},{"DocComment":" reference to a `K` as the key to search for would require to always"},{"DocComment":" create such an owned value. For string keys, this would mean a `String`"},{"DocComment":" value needs to be created just for the search for cases where only a"},{"DocComment":" `str` is available."},{"DocComment":""},{"DocComment":" Instead, the `get` method is generic over the type of the underlying key"},{"DocComment":" data, called `Q` in the method signature above. It states that `K`"},{"DocComment":" borrows as a `Q` by requiring that `K: Borrow<Q>`. By additionally"},{"DocComment":" requiring `Q: Hash + Eq`, it signals the requirement that `K` and `Q`"},{"DocComment":" have implementations of the `Hash` and `Eq` traits that produce identical"},{"DocComment":" results."},{"DocComment":""},{"DocComment":" The implementation of `get` relies in particular on identical"},{"DocComment":" implementations of `Hash` by determining the key’s hash bucket by calling"},{"DocComment":" `Hash::hash` on the `Q` value even though it inserted the key based on"},{"DocComment":" the hash value calculated from the `K` value."},{"DocComment":""},{"DocComment":" As a consequence, the hash map breaks if a `K` wrapping a `Q` value"},{"DocComment":" produces a different hash than `Q`. For instance, imagine you have a"},{"DocComment":" type that wraps a string but compares ASCII letters ignoring their case:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" pub struct CaseInsensitiveString(String);"},{"DocComment":""},{"DocComment":" impl PartialEq for CaseInsensitiveString {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.0.eq_ignore_ascii_case(&other.0)"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for CaseInsensitiveString { }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Because two equal values need to produce the same hash value, the"},{"DocComment":" implementation of `Hash` needs to ignore ASCII case, too:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # use std::hash::{Hash, Hasher};"},{"DocComment":" # pub struct CaseInsensitiveString(String);"},{"DocComment":" impl Hash for CaseInsensitiveString {"},{"DocComment":"     fn hash<H: Hasher>(&self, state: &mut H) {"},{"DocComment":"         for c in self.0.as_bytes() {"},{"DocComment":"             c.to_ascii_lowercase().hash(state)"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Can `CaseInsensitiveString` implement `Borrow<str>`? It certainly can"},{"DocComment":" provide a reference to a string slice via its contained owned string."},{"DocComment":" But because its `Hash` implementation differs, it behaves differently"},{"DocComment":" from `str` and therefore must not, in fact, implement `Borrow<str>`."},{"DocComment":" If it wants to allow others access to the underlying `str`, it can do"},{"DocComment":" that via `AsRef<str>` which doesn’t carry any extra requirements."},{"DocComment":""},{"DocComment":" [`Hash`]: crate::hash::Hash"},{"DocComment":" [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html"},{"DocComment":" [`String`]: ../../std/string/struct.String.html"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"Borrow\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Borrow"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Borrowed"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["borrow",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":17,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":8,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[8,"borrow"]}}]],"vtable":{"id":{"Adt":6},"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}},{"def_id":9,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Ident":["Step",0]}],"span":{"span":{"file_id":23,"beg":{"line":25,"col":0},"end":{"line":25,"col":42}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Objects that have a notion of *successor* and *predecessor* operations."},{"DocComment":""},{"DocComment":" The *successor* operation moves towards values that compare greater."},{"DocComment":" The *predecessor* operation moves towards values that compare lesser."},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"range_step\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"range_step"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":23,"beg":{"line":25,"col":16},"end":{"line":25,"col":21}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":12,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":2,"span":{"span":{"file_id":23,"beg":{"line":25,"col":24},"end":{"line":25,"col":34}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":13,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["steps_between",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":22,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[9,"steps_between"]}}],["forward_checked",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":23,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[9,"forward_checked"]}}],["backward_checked",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":26,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[9,"backward_checked"]}}]],"vtable":null},{"def_id":10,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["Hasher",0]}],"span":{"span":{"file_id":20,"beg":{"line":313,"col":0},"end":{"line":313,"col":16}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A trait for hashing an arbitrary stream of bytes."},{"DocComment":""},{"DocComment":" Instances of `Hasher` usually represent state that is changed while hashing"},{"DocComment":" data."},{"DocComment":""},{"DocComment":" `Hasher` provides a fairly basic interface for retrieving the generated hash"},{"DocComment":" (with [`finish`]), and writing integers as well as slices of bytes into an"},{"DocComment":" instance (with [`write`] and [`write_u8`] etc.). Most of the time, `Hasher`"},{"DocComment":" instances are used in conjunction with the [`Hash`] trait."},{"DocComment":""},{"DocComment":" This trait provides no guarantees about how the various `write_*` methods are"},{"DocComment":" defined and implementations of [`Hash`] should not assume that they work one"},{"DocComment":" way or another. You cannot assume, for example, that a [`write_u32`] call is"},{"DocComment":" equivalent to four calls of [`write_u8`].  Nor can you assume that adjacent"},{"DocComment":" `write` calls are merged, so it's possible, for example, that"},{"DocComment":" ```"},{"DocComment":" # fn foo(hasher: &mut impl std::hash::Hasher) {"},{"DocComment":" hasher.write(&[1, 2]);"},{"DocComment":" hasher.write(&[3, 4, 5, 6]);"},{"DocComment":" # }"},{"DocComment":" ```"},{"DocComment":" and"},{"DocComment":" ```"},{"DocComment":" # fn foo(hasher: &mut impl std::hash::Hasher) {"},{"DocComment":" hasher.write(&[1, 2, 3, 4]);"},{"DocComment":" hasher.write(&[5, 6]);"},{"DocComment":" # }"},{"DocComment":" ```"},{"DocComment":" end up producing different hashes."},{"DocComment":""},{"DocComment":" Thus to produce the same hash value, [`Hash`] implementations must ensure"},{"DocComment":" for equivalent items that exactly the same sequence of calls is made -- the"},{"DocComment":" same methods with the same parameters in the same order."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::hash::{DefaultHasher, Hasher};"},{"DocComment":""},{"DocComment":" let mut hasher = DefaultHasher::new();"},{"DocComment":""},{"DocComment":" hasher.write_u32(1989);"},{"DocComment":" hasher.write_u8(11);"},{"DocComment":" hasher.write_u8(9);"},{"DocComment":" hasher.write(b\"Huh?\");"},{"DocComment":""},{"DocComment":" println!(\"Hash is {:x}!\", hasher.finish());"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`finish`]: Hasher::finish"},{"DocComment":" [`write`]: Hasher::write"},{"DocComment":" [`write_u8`]: Hasher::write_u8"},{"DocComment":" [`write_u32`]: Hasher::write_u32"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["finish",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":16,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[10,"finish"]}}],["write",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":15,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[10,"write"]}}]],"vtable":{"id":{"Adt":12},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"def_id":11,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialEq",0]}],"span":{"span":{"file_id":19,"beg":{"line":252,"col":0},"end":{"line":252,"col":59}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait for comparisons using the equality operator."},{"DocComment":""},{"DocComment":" Implementing this trait for types provides the `==` and `!=` operators for"},{"DocComment":" those types."},{"DocComment":""},{"DocComment":" `x.eq(y)` can also be written `x == y`, and `x.ne(y)` can be written `x != y`."},{"DocComment":" We use the easier-to-read infix notation in the remainder of this documentation."},{"DocComment":""},{"DocComment":" This trait allows for comparisons using the equality operator, for types"},{"DocComment":" that do not have a full equivalence relation. For example, in floating point"},{"DocComment":" numbers `NaN != NaN`, so floating point types implement `PartialEq` but not"},{"DocComment":" [`trait@Eq`]. Formally speaking, when `Rhs == Self`, this trait corresponds"},{"DocComment":" to a [partial equivalence relation]."},{"DocComment":""},{"DocComment":" [partial equivalence relation]: https://en.wikipedia.org/wiki/Partial_equivalence_relation"},{"DocComment":""},{"DocComment":" Implementations must ensure that `eq` and `ne` are consistent with each other:"},{"DocComment":""},{"DocComment":" - `a != b` if and only if `!(a == b)`."},{"DocComment":""},{"DocComment":" The default implementation of `ne` provides this consistency and is almost"},{"DocComment":" always sufficient. It should not be overridden without very good reason."},{"DocComment":""},{"DocComment":" If [`PartialOrd`] or [`Ord`] are also implemented for `Self` and `Rhs`, their methods must also"},{"DocComment":" be consistent with `PartialEq` (see the documentation of those traits for the exact"},{"DocComment":" requirements). It's easy to accidentally make them disagree by deriving some of the traits and"},{"DocComment":" manually implementing others."},{"DocComment":""},{"DocComment":" The equality relation `==` must satisfy the following conditions"},{"DocComment":" (for all `a`, `b`, `c` of type `A`, `B`, `C`):"},{"DocComment":""},{"DocComment":" - **Symmetry**: if `A: PartialEq<B>` and `B: PartialEq<A>`, then **`a == b`"},{"DocComment":"   implies `b == a`**; and"},{"DocComment":""},{"DocComment":" - **Transitivity**: if `A: PartialEq<B>` and `B: PartialEq<C>` and `A:"},{"DocComment":"   PartialEq<C>`, then **`a == b` and `b == c` implies `a == c`**."},{"DocComment":"   This must also work for longer chains, such as when `A: PartialEq<B>`, `B: PartialEq<C>`,"},{"DocComment":"   `C: PartialEq<D>`, and `A: PartialEq<D>` all exist."},{"DocComment":""},{"DocComment":" Note that the `B: PartialEq<A>` (symmetric) and `A: PartialEq<C>`"},{"DocComment":" (transitive) impls are not forced to exist, but these requirements apply"},{"DocComment":" whenever they do exist."},{"DocComment":""},{"DocComment":" Violating these requirements is a logic error. The behavior resulting from a logic error is not"},{"DocComment":" specified, but users of the trait must ensure that such logic errors do *not* result in"},{"DocComment":" undefined behavior. This means that `unsafe` code **must not** rely on the correctness of these"},{"DocComment":" methods."},{"DocComment":""},{"DocComment":" ## Cross-crate considerations"},{"DocComment":""},{"DocComment":" Upholding the requirements stated above can become tricky when one crate implements `PartialEq`"},{"DocComment":" for a type of another crate (i.e., to allow comparing one of its own types with a type from the"},{"DocComment":" standard library). The recommendation is to never implement this trait for a foreign type. In"},{"DocComment":" other words, such a crate should do `impl PartialEq<ForeignType> for LocalType`, but it should"},{"DocComment":" *not* do `impl PartialEq<LocalType> for ForeignType`."},{"DocComment":""},{"DocComment":" This avoids the problem of transitive chains that criss-cross crate boundaries: for all local"},{"DocComment":" types `T`, you may assume that no other crate will add `impl`s that allow comparing `T == U`. In"},{"DocComment":" other words, if other crates add `impl`s that allow building longer transitive chains `U1 == ..."},{"DocComment":" == T == V1 == ...`, then all the types that appear to the right of `T` must be types that the"},{"DocComment":" crate defining `T` already knows about. This rules out transitive chains where downstream crates"},{"DocComment":" can add new `impl`s that \"stitch together\" comparisons of foreign types in ways that violate"},{"DocComment":" transitivity."},{"DocComment":""},{"DocComment":" Not having such foreign `impl`s also avoids forward compatibility issues where one crate adding"},{"DocComment":" more `PartialEq` implementations can cause build failures in downstream crates."},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]`. When `derive`d on structs, two"},{"DocComment":" instances are equal if all fields are equal, and not equal if any fields"},{"DocComment":" are not equal. When `derive`d on enums, two instances are equal if they"},{"DocComment":" are the same variant and all fields are equal."},{"DocComment":""},{"DocComment":" ## How can I implement `PartialEq`?"},{"DocComment":""},{"DocComment":" An example implementation for a domain in which two books are considered"},{"DocComment":" the same book if their ISBN matches, even if the formats differ:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" enum BookFormat {"},{"DocComment":"     Paperback,"},{"DocComment":"     Hardback,"},{"DocComment":"     Ebook,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" struct Book {"},{"DocComment":"     isbn: i32,"},{"DocComment":"     format: BookFormat,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Book {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.isbn == other.isbn"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let b1 = Book { isbn: 3, format: BookFormat::Paperback };"},{"DocComment":" let b2 = Book { isbn: 3, format: BookFormat::Ebook };"},{"DocComment":" let b3 = Book { isbn: 10, format: BookFormat::Paperback };"},{"DocComment":""},{"DocComment":" assert!(b1 == b2);"},{"DocComment":" assert!(b1 != b3);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## How can I compare two different types?"},{"DocComment":""},{"DocComment":" The type you can compare with is controlled by `PartialEq`'s type parameter."},{"DocComment":" For example, let's tweak our previous code a bit:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // The derive implements <BookFormat> == <BookFormat> comparisons"},{"DocComment":" #[derive(PartialEq)]"},{"DocComment":" enum BookFormat {"},{"DocComment":"     Paperback,"},{"DocComment":"     Hardback,"},{"DocComment":"     Ebook,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" struct Book {"},{"DocComment":"     isbn: i32,"},{"DocComment":"     format: BookFormat,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Implement <Book> == <BookFormat> comparisons"},{"DocComment":" impl PartialEq<BookFormat> for Book {"},{"DocComment":"     fn eq(&self, other: &BookFormat) -> bool {"},{"DocComment":"         self.format == *other"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Implement <BookFormat> == <Book> comparisons"},{"DocComment":" impl PartialEq<Book> for BookFormat {"},{"DocComment":"     fn eq(&self, other: &Book) -> bool {"},{"DocComment":"         *self == other.format"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let b1 = Book { isbn: 3, format: BookFormat::Paperback };"},{"DocComment":""},{"DocComment":" assert!(b1 == BookFormat::Paperback);"},{"DocComment":" assert!(BookFormat::Ebook != b1);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" By changing `impl PartialEq for Book` to `impl PartialEq<BookFormat> for Book`,"},{"DocComment":" we allow `BookFormat`s to be compared with `Book`s."},{"DocComment":""},{"DocComment":" A comparison like the one above, which ignores some fields of the struct,"},{"DocComment":" can be dangerous. It can easily lead to an unintended violation of the"},{"DocComment":" requirements for a partial equivalence relation. For example, if we kept"},{"DocComment":" the above implementation of `PartialEq<Book>` for `BookFormat` and added an"},{"DocComment":" implementation of `PartialEq<Book>` for `Book` (either via a `#[derive]` or"},{"DocComment":" via the manual implementation from the first example) then the result would"},{"DocComment":" violate transitivity:"},{"DocComment":""},{"DocComment":" ```should_panic"},{"DocComment":" #[derive(PartialEq)]"},{"DocComment":" enum BookFormat {"},{"DocComment":"     Paperback,"},{"DocComment":"     Hardback,"},{"DocComment":"     Ebook,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" #[derive(PartialEq)]"},{"DocComment":" struct Book {"},{"DocComment":"     isbn: i32,"},{"DocComment":"     format: BookFormat,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq<BookFormat> for Book {"},{"DocComment":"     fn eq(&self, other: &BookFormat) -> bool {"},{"DocComment":"         self.format == *other"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq<Book> for BookFormat {"},{"DocComment":"     fn eq(&self, other: &Book) -> bool {"},{"DocComment":"         *self == other.format"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" fn main() {"},{"DocComment":"     let b1 = Book { isbn: 1, format: BookFormat::Paperback };"},{"DocComment":"     let b2 = Book { isbn: 2, format: BookFormat::Paperback };"},{"DocComment":""},{"DocComment":"     assert!(b1 == BookFormat::Paperback);"},{"DocComment":"     assert!(BookFormat::Paperback == b2);"},{"DocComment":""},{"DocComment":"     // The following should hold by transitivity but doesn't."},{"DocComment":"     assert!(b1 == b2); // <-- PANICS"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let x: u32 = 0;"},{"DocComment":" let y: u32 = 1;"},{"DocComment":""},{"DocComment":" assert_eq!(x == y, false);"},{"DocComment":" assert_eq!(x.eq(&y), false);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`eq`]: PartialEq::eq"},{"DocComment":" [`ne`]: PartialEq::ne"},{"Unknown":{"path":"doc","args":"alias = \"==\""}},{"Unknown":{"path":"doc","args":"alias = \"!=\""}},{"Unknown":{"path":"rustc_on_unimplemented","args":"message = \"can't compare `{Self}` with `{Rhs}`\", label =\n\"no implementation for `{Self} == {Rhs}`\", append_const_msg"}},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"PartialEq\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"eq"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Rhs"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["eq",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":20,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":11,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[11,"eq"]}}]],"vtable":{"id":{"Adt":7},"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}},{"def_id":12,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["Clone",0]}],"span":{"span":{"file_id":24,"beg":{"line":162,"col":0},"end":{"line":162,"col":22}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A common trait that allows explicit creation of a duplicate value."},{"DocComment":""},{"DocComment":" Calling [`clone`] always produces a new value."},{"DocComment":" However, for types that are references to other data (such as smart pointers or references),"},{"DocComment":" the new value may still point to the same underlying data, rather than duplicating it."},{"DocComment":" See [`Clone::clone`] for more details."},{"DocComment":""},{"DocComment":" This distinction is especially important when using `#[derive(Clone)]` on structs containing"},{"DocComment":" smart pointers like `Arc<Mutex<T>>` - the cloned struct will share mutable state with the"},{"DocComment":" original."},{"DocComment":""},{"DocComment":" Differs from [`Copy`] in that [`Copy`] is implicit and an inexpensive bit-wise copy, while"},{"DocComment":" `Clone` is always explicit and may or may not be expensive. In order to enforce"},{"DocComment":" these characteristics, Rust does not allow you to reimplement [`Copy`], but you"},{"DocComment":" may reimplement `Clone` and run arbitrary code."},{"DocComment":""},{"DocComment":" Since `Clone` is more general than [`Copy`], you can automatically make anything"},{"DocComment":" [`Copy`] be `Clone` as well."},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d"},{"DocComment":" implementation of [`Clone`] calls [`clone`] on each field."},{"DocComment":""},{"DocComment":" [`clone`]: Clone::clone"},{"DocComment":""},{"DocComment":" For a generic struct, `#[derive]` implements `Clone` conditionally by adding bound `Clone` on"},{"DocComment":" generic parameters."},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // `derive` implements Clone for Reading<T> when T is Clone."},{"DocComment":" #[derive(Clone)]"},{"DocComment":" struct Reading<T> {"},{"DocComment":"     frequency: T,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## How can I implement `Clone`?"},{"DocComment":""},{"DocComment":" Types that are [`Copy`] should have a trivial implementation of `Clone`. More formally:"},{"DocComment":" if `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`."},{"DocComment":" Manual implementations should be careful to uphold this invariant; however, unsafe code"},{"DocComment":" must not rely on it to ensure memory safety."},{"DocComment":""},{"DocComment":" An example is a generic struct holding a function pointer. In this case, the"},{"DocComment":" implementation of `Clone` cannot be `derive`d, but can be implemented as:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" struct Generate<T>(fn() -> T);"},{"DocComment":""},{"DocComment":" impl<T> Copy for Generate<T> {}"},{"DocComment":""},{"DocComment":" impl<T> Clone for Generate<T> {"},{"DocComment":"     fn clone(&self) -> Self {"},{"DocComment":"         *self"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" If we `derive`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct Generate<T>(fn() -> T);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" the auto-derived implementations will have unnecessary `T: Copy` and `T: Clone` bounds:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # struct Generate<T>(fn() -> T);"},{"DocComment":""},{"DocComment":" // Automatically derived"},{"DocComment":" impl<T: Copy> Copy for Generate<T> { }"},{"DocComment":""},{"DocComment":" // Automatically derived"},{"DocComment":" impl<T: Clone> Clone for Generate<T> {"},{"DocComment":"     fn clone(&self) -> Generate<T> {"},{"DocComment":"         Generate(Clone::clone(&self.0))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The bounds are unnecessary because clearly the function itself should be"},{"DocComment":" copy- and cloneable even if its return type is not:"},{"DocComment":""},{"DocComment":" ```compile_fail,E0599"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct Generate<T>(fn() -> T);"},{"DocComment":""},{"DocComment":" struct NotCloneable;"},{"DocComment":""},{"DocComment":" fn generate_not_cloneable() -> NotCloneable {"},{"DocComment":"     NotCloneable"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" Generate(generate_not_cloneable).clone(); // error: trait bounds were not satisfied"},{"DocComment":" // Note: With the manual implementations the above line will compile."},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Additional implementors"},{"DocComment":""},{"DocComment":" In addition to the [implementors listed below][impls],"},{"DocComment":" the following types also implement `Clone`:"},{"DocComment":""},{"DocComment":" * Function item types (i.e., the distinct types defined for each function)"},{"DocComment":" * Function pointer types (e.g., `fn() -> i32`)"},{"DocComment":" * Closure types, if they capture no value from the environment"},{"DocComment":"   or if all such captured values implement `Clone` themselves."},{"DocComment":"   Note that variables captured by shared reference always implement `Clone`"},{"DocComment":"   (even if the referent doesn't),"},{"DocComment":"   while variables captured by mutable reference never implement `Clone`."},{"DocComment":""},{"DocComment":" [impls]: #implementors"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"Clone\""}},{"Unknown":{"path":"rustc_trivial_field_reads","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"clone"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["clone",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":29,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":12,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[12,"clone"]}}]],"vtable":null},{"def_id":13,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["PartialOrd",0]}],"span":{"span":{"file_id":19,"beg":{"line":1344,"col":0},"end":{"line":1344,"col":77}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait for types that form a [partial order](https://en.wikipedia.org/wiki/Partial_order)."},{"DocComment":""},{"DocComment":" The `lt`, `le`, `gt`, and `ge` methods of this trait can be called using the `<`, `<=`, `>`, and"},{"DocComment":" `>=` operators, respectively."},{"DocComment":""},{"DocComment":" This trait should **only** contain the comparison logic for a type **if one plans on only"},{"DocComment":" implementing `PartialOrd` but not [`Ord`]**. Otherwise the comparison logic should be in [`Ord`]"},{"DocComment":" and this trait implemented with `Some(self.cmp(other))`."},{"DocComment":""},{"DocComment":" The methods of this trait must be consistent with each other and with those of [`PartialEq`]."},{"DocComment":" The following conditions must hold:"},{"DocComment":""},{"DocComment":" 1. `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`."},{"DocComment":" 2. `a < b` if and only if `partial_cmp(a, b) == Some(Less)`"},{"DocComment":" 3. `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`"},{"DocComment":" 4. `a <= b` if and only if `a < b || a == b`"},{"DocComment":" 5. `a >= b` if and only if `a > b || a == b`"},{"DocComment":" 6. `a != b` if and only if `!(a == b)`."},{"DocComment":""},{"DocComment":" Conditions 2–5 above are ensured by the default implementation. Condition 6 is already ensured"},{"DocComment":" by [`PartialEq`]."},{"DocComment":""},{"DocComment":" If [`Ord`] is also implemented for `Self` and `Rhs`, it must also be consistent with"},{"DocComment":" `partial_cmp` (see the documentation of that trait for the exact requirements). It's easy to"},{"DocComment":" accidentally make them disagree by deriving some of the traits and manually implementing others."},{"DocComment":""},{"DocComment":" The comparison relations must satisfy the following conditions (for all `a`, `b`, `c` of type"},{"DocComment":" `A`, `B`, `C`):"},{"DocComment":""},{"DocComment":" - **Transitivity**: if `A: PartialOrd<B>` and `B: PartialOrd<C>` and `A: PartialOrd<C>`, then `a"},{"DocComment":"   < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`. This must also"},{"DocComment":"   work for longer chains, such as when `A: PartialOrd<B>`, `B: PartialOrd<C>`, `C:"},{"DocComment":"   PartialOrd<D>`, and `A: PartialOrd<D>` all exist."},{"DocComment":" - **Duality**: if `A: PartialOrd<B>` and `B: PartialOrd<A>`, then `a < b` if and only if `b >"},{"DocComment":"   a`."},{"DocComment":""},{"DocComment":" Note that the `B: PartialOrd<A>` (dual) and `A: PartialOrd<C>` (transitive) impls are not forced"},{"DocComment":" to exist, but these requirements apply whenever they do exist."},{"DocComment":""},{"DocComment":" Violating these requirements is a logic error. The behavior resulting from a logic error is not"},{"DocComment":" specified, but users of the trait must ensure that such logic errors do *not* result in"},{"DocComment":" undefined behavior. This means that `unsafe` code **must not** rely on the correctness of these"},{"DocComment":" methods."},{"DocComment":""},{"DocComment":" ## Cross-crate considerations"},{"DocComment":""},{"DocComment":" Upholding the requirements stated above can become tricky when one crate implements `PartialOrd`"},{"DocComment":" for a type of another crate (i.e., to allow comparing one of its own types with a type from the"},{"DocComment":" standard library). The recommendation is to never implement this trait for a foreign type. In"},{"DocComment":" other words, such a crate should do `impl PartialOrd<ForeignType> for LocalType`, but it should"},{"DocComment":" *not* do `impl PartialOrd<LocalType> for ForeignType`."},{"DocComment":""},{"DocComment":" This avoids the problem of transitive chains that criss-cross crate boundaries: for all local"},{"DocComment":" types `T`, you may assume that no other crate will add `impl`s that allow comparing `T < U`. In"},{"DocComment":" other words, if other crates add `impl`s that allow building longer transitive chains `U1 < ..."},{"DocComment":" < T < V1 < ...`, then all the types that appear to the right of `T` must be types that the crate"},{"DocComment":" defining `T` already knows about. This rules out transitive chains where downstream crates can"},{"DocComment":" add new `impl`s that \"stitch together\" comparisons of foreign types in ways that violate"},{"DocComment":" transitivity."},{"DocComment":""},{"DocComment":" Not having such foreign `impl`s also avoids forward compatibility issues where one crate adding"},{"DocComment":" more `PartialOrd` implementations can cause build failures in downstream crates."},{"DocComment":""},{"DocComment":" ## Corollaries"},{"DocComment":""},{"DocComment":" The following corollaries follow from the above requirements:"},{"DocComment":""},{"DocComment":" - irreflexivity of `<` and `>`: `!(a < a)`, `!(a > a)`"},{"DocComment":" - transitivity of `>`: if `a > b` and `b > c` then `a > c`"},{"DocComment":" - duality of `partial_cmp`: `partial_cmp(a, b) == partial_cmp(b, a).map(Ordering::reverse)`"},{"DocComment":""},{"DocComment":" ## Strict and non-strict partial orders"},{"DocComment":""},{"DocComment":" The `<` and `>` operators behave according to a *strict* partial order. However, `<=` and `>=`"},{"DocComment":" do **not** behave according to a *non-strict* partial order. That is because mathematically, a"},{"DocComment":" non-strict partial order would require reflexivity, i.e. `a <= a` would need to be true for"},{"DocComment":" every `a`. This isn't always the case for types that implement `PartialOrd`, for example:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let a = f64::sqrt(-1.0);"},{"DocComment":" assert_eq!(a <= a, false);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]`."},{"DocComment":""},{"DocComment":" When `derive`d on structs, it will produce a"},{"DocComment":" [lexicographic](https://en.wikipedia.org/wiki/Lexicographic_order) ordering based on the"},{"DocComment":" top-to-bottom declaration order of the struct's members."},{"DocComment":""},{"DocComment":" When `derive`d on enums, variants are primarily ordered by their discriminants. Secondarily,"},{"DocComment":" they are ordered by their fields. By default, the discriminant is smallest for variants at the"},{"DocComment":" top, and largest for variants at the bottom. Here's an example:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(PartialEq, PartialOrd)]"},{"DocComment":" enum E {"},{"DocComment":"     Top,"},{"DocComment":"     Bottom,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert!(E::Top < E::Bottom);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" However, manually setting the discriminants can override this default behavior:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(PartialEq, PartialOrd)]"},{"DocComment":" enum E {"},{"DocComment":"     Top = 2,"},{"DocComment":"     Bottom = 1,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert!(E::Bottom < E::Top);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## How can I implement `PartialOrd`?"},{"DocComment":""},{"DocComment":" `PartialOrd` only requires implementation of the [`partial_cmp`] method, with the others"},{"DocComment":" generated from default implementations."},{"DocComment":""},{"DocComment":" However it remains possible to implement the others separately for types which do not have a"},{"DocComment":" total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 == false`"},{"DocComment":" (cf. IEEE 754-2008 section 5.11)."},{"DocComment":""},{"DocComment":" `PartialOrd` requires your type to be [`PartialEq`]."},{"DocComment":""},{"DocComment":" If your type is [`Ord`], you can implement [`partial_cmp`] by using [`cmp`]:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" struct Person {"},{"DocComment":"     id: u32,"},{"DocComment":"     name: String,"},{"DocComment":"     height: u32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Person {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         Some(self.cmp(other))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Ord for Person {"},{"DocComment":"     fn cmp(&self, other: &Self) -> Ordering {"},{"DocComment":"         self.height.cmp(&other.height)"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Person {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.height == other.height"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for Person {}"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" You may also find it useful to use [`partial_cmp`] on your type's fields. Here is an example of"},{"DocComment":" `Person` types who have a floating-point `height` field that is the only field to be used for"},{"DocComment":" sorting:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" struct Person {"},{"DocComment":"     id: u32,"},{"DocComment":"     name: String,"},{"DocComment":"     height: f64,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Person {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         self.height.partial_cmp(&other.height)"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Person {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.height == other.height"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Examples of incorrect `PartialOrd` implementations"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" #[derive(PartialEq, Debug)]"},{"DocComment":" struct Character {"},{"DocComment":"     health: u32,"},{"DocComment":"     experience: u32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Character {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         Some(self.health.cmp(&other.health))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let a = Character {"},{"DocComment":"     health: 10,"},{"DocComment":"     experience: 5,"},{"DocComment":" };"},{"DocComment":" let b = Character {"},{"DocComment":"     health: 10,"},{"DocComment":"     experience: 77,"},{"DocComment":" };"},{"DocComment":""},{"DocComment":" // Mistake: `PartialEq` and `PartialOrd` disagree with each other."},{"DocComment":""},{"DocComment":" assert_eq!(a.partial_cmp(&b).unwrap(), Ordering::Equal); // a == b according to `PartialOrd`."},{"DocComment":" assert_ne!(a, b); // a != b according to `PartialEq`."},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let x: u32 = 0;"},{"DocComment":" let y: u32 = 1;"},{"DocComment":""},{"DocComment":" assert_eq!(x < y, true);"},{"DocComment":" assert_eq!(x.lt(&y), true);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" [`partial_cmp`]: PartialOrd::partial_cmp"},{"DocComment":" [`cmp`]: Ord::cmp"},{"Unknown":{"path":"doc","args":"alias = \">\""}},{"Unknown":{"path":"doc","args":"alias = \"<\""}},{"Unknown":{"path":"doc","args":"alias = \"<=\""}},{"Unknown":{"path":"doc","args":"alias = \">=\""}},{"Unknown":{"path":"rustc_on_unimplemented","args":"message = \"can't compare `{Self}` with `{Rhs}`\", label =\n\"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\",\nappend_const_msg"}},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"PartialOrd\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"partial_ord"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Rhs"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":19,"beg":{"line":1344,"col":48},"end":{"line":1344,"col":62}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":11,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["partial_cmp",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":31,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":13,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[13,"partial_cmp"]}}]],"vtable":{"id":{"Adt":8},"generics":{"regions":[],"types":[{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}},null,{"def_id":15,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["Ord",0]}],"span":{"span":{"file_id":19,"beg":{"line":960,"col":0},"end":{"line":960,"col":51}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order)."},{"DocComment":""},{"DocComment":" Implementations must be consistent with the [`PartialOrd`] implementation, and ensure `max`,"},{"DocComment":" `min`, and `clamp` are consistent with `cmp`:"},{"DocComment":""},{"DocComment":" - `partial_cmp(a, b) == Some(cmp(a, b))`."},{"DocComment":" - `max(a, b) == max_by(a, b, cmp)` (ensured by the default implementation)."},{"DocComment":" - `min(a, b) == min_by(a, b, cmp)` (ensured by the default implementation)."},{"DocComment":" - For `a.clamp(min, max)`, see the [method docs](#method.clamp) (ensured by the default"},{"DocComment":"   implementation)."},{"DocComment":""},{"DocComment":" Violating these requirements is a logic error. The behavior resulting from a logic error is not"},{"DocComment":" specified, but users of the trait must ensure that such logic errors do *not* result in"},{"DocComment":" undefined behavior. This means that `unsafe` code **must not** rely on the correctness of these"},{"DocComment":" methods."},{"DocComment":""},{"DocComment":" ## Corollaries"},{"DocComment":""},{"DocComment":" From the above and the requirements of `PartialOrd`, it follows that for all `a`, `b` and `c`:"},{"DocComment":""},{"DocComment":" - exactly one of `a < b`, `a == b` or `a > b` is true; and"},{"DocComment":" - `<` is transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and"},{"DocComment":"   `>`."},{"DocComment":""},{"DocComment":" Mathematically speaking, the `<` operator defines a strict [weak order]. In cases where `==`"},{"DocComment":" conforms to mathematical equality, it also defines a strict [total order]."},{"DocComment":""},{"DocComment":" [weak order]: https://en.wikipedia.org/wiki/Weak_ordering"},{"DocComment":" [total order]: https://en.wikipedia.org/wiki/Total_order"},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]`."},{"DocComment":""},{"DocComment":" When `derive`d on structs, it will produce a"},{"DocComment":" [lexicographic](https://en.wikipedia.org/wiki/Lexicographic_order) ordering based on the"},{"DocComment":" top-to-bottom declaration order of the struct's members."},{"DocComment":""},{"DocComment":" When `derive`d on enums, variants are ordered primarily by their discriminants. Secondarily,"},{"DocComment":" they are ordered by their fields. By default, the discriminant is smallest for variants at the"},{"DocComment":" top, and largest for variants at the bottom. Here's an example:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(PartialEq, Eq, PartialOrd, Ord)]"},{"DocComment":" enum E {"},{"DocComment":"     Top,"},{"DocComment":"     Bottom,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert!(E::Top < E::Bottom);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" However, manually setting the discriminants can override this default behavior:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(PartialEq, Eq, PartialOrd, Ord)]"},{"DocComment":" enum E {"},{"DocComment":"     Top = 2,"},{"DocComment":"     Bottom = 1,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert!(E::Bottom < E::Top);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Lexicographical comparison"},{"DocComment":""},{"DocComment":" Lexicographical comparison is an operation with the following properties:"},{"DocComment":"  - Two sequences are compared element by element."},{"DocComment":"  - The first mismatching element defines which sequence is lexicographically less or greater"},{"DocComment":"    than the other."},{"DocComment":"  - If one sequence is a prefix of another, the shorter sequence is lexicographically less than"},{"DocComment":"    the other."},{"DocComment":"  - If two sequences have equivalent elements and are of the same length, then the sequences are"},{"DocComment":"    lexicographically equal."},{"DocComment":"  - An empty sequence is lexicographically less than any non-empty sequence."},{"DocComment":"  - Two empty sequences are lexicographically equal."},{"DocComment":""},{"DocComment":" ## How can I implement `Ord`?"},{"DocComment":""},{"DocComment":" `Ord` requires that the type also be [`PartialOrd`], [`PartialEq`], and [`Eq`]."},{"DocComment":""},{"DocComment":" Because `Ord` implies a stronger ordering relationship than [`PartialOrd`], and both `Ord` and"},{"DocComment":" [`PartialOrd`] must agree, you must choose how to implement `Ord` **first**. You can choose to"},{"DocComment":" derive it, or implement it manually. If you derive it, you should derive all four traits. If you"},{"DocComment":" implement it manually, you should manually implement all four traits, based on the"},{"DocComment":" implementation of `Ord`."},{"DocComment":""},{"DocComment":" Here's an example where you want to define the `Character` comparison by `health` and"},{"DocComment":" `experience` only, disregarding the field `mana`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" struct Character {"},{"DocComment":"     health: u32,"},{"DocComment":"     experience: u32,"},{"DocComment":"     mana: f32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Ord for Character {"},{"DocComment":"     fn cmp(&self, other: &Self) -> Ordering {"},{"DocComment":"         self.experience"},{"DocComment":"             .cmp(&other.experience)"},{"DocComment":"             .then(self.health.cmp(&other.health))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Character {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         Some(self.cmp(other))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Character {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.health == other.health && self.experience == other.experience"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for Character {}"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" If all you need is to `slice::sort` a type by a field value, it can be simpler to use"},{"DocComment":" `slice::sort_by_key`."},{"DocComment":""},{"DocComment":" ## Examples of incorrect `Ord` implementations"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct Character {"},{"DocComment":"     health: f32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Ord for Character {"},{"DocComment":"     fn cmp(&self, other: &Self) -> std::cmp::Ordering {"},{"DocComment":"         if self.health < other.health {"},{"DocComment":"             Ordering::Less"},{"DocComment":"         } else if self.health > other.health {"},{"DocComment":"             Ordering::Greater"},{"DocComment":"         } else {"},{"DocComment":"             Ordering::Equal"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Character {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         Some(self.cmp(other))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialEq for Character {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.health == other.health"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for Character {}"},{"DocComment":""},{"DocComment":" let a = Character { health: 4.5 };"},{"DocComment":" let b = Character { health: f32::NAN };"},{"DocComment":""},{"DocComment":" // Mistake: floating-point values do not form a total order and using the built-in comparison"},{"DocComment":" // operands to implement `Ord` irregardless of that reality does not change it. Use"},{"DocComment":" // `f32::total_cmp` if you need a total order for floating-point values."},{"DocComment":""},{"DocComment":" // Reflexivity requirement of `Ord` is not given."},{"DocComment":" assert!(a == a);"},{"DocComment":" assert!(b != b);"},{"DocComment":""},{"DocComment":" // Antisymmetry requirement of `Ord` is not given. Only one of a < c and c < a is allowed to be"},{"DocComment":" // true, not both or neither."},{"DocComment":" assert_eq!((a < b) as u8 + (b < a) as u8, 0);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::cmp::Ordering;"},{"DocComment":""},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct Character {"},{"DocComment":"     health: u32,"},{"DocComment":"     experience: u32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl PartialOrd for Character {"},{"DocComment":"     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {"},{"DocComment":"         Some(self.cmp(other))"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Ord for Character {"},{"DocComment":"     fn cmp(&self, other: &Self) -> std::cmp::Ordering {"},{"DocComment":"         if self.health < 50 {"},{"DocComment":"             self.health.cmp(&other.health)"},{"DocComment":"         } else {"},{"DocComment":"             self.experience.cmp(&other.experience)"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // For performance reasons implementing `PartialEq` this way is not the idiomatic way, but it"},{"DocComment":" // ensures consistent behavior between `PartialEq`, `PartialOrd` and `Ord` in this example."},{"DocComment":" impl PartialEq for Character {"},{"DocComment":"     fn eq(&self, other: &Self) -> bool {"},{"DocComment":"         self.cmp(other) == Ordering::Equal"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Eq for Character {}"},{"DocComment":""},{"DocComment":" let a = Character {"},{"DocComment":"     health: 3,"},{"DocComment":"     experience: 5,"},{"DocComment":" };"},{"DocComment":" let b = Character {"},{"DocComment":"     health: 10,"},{"DocComment":"     experience: 77,"},{"DocComment":" };"},{"DocComment":" let c = Character {"},{"DocComment":"     health: 143,"},{"DocComment":"     experience: 2,"},{"DocComment":" };"},{"DocComment":""},{"DocComment":" // Mistake: The implementation of `Ord` compares different fields depending on the value of"},{"DocComment":" // `self.health`, the resulting order is not total."},{"DocComment":""},{"DocComment":" // Transitivity requirement of `Ord` is not given. If a is smaller than b and b is smaller than"},{"DocComment":" // c, by transitive property a must also be smaller than c."},{"DocComment":" assert!(a < b && b < c && c < a);"},{"DocComment":""},{"DocComment":" // Antisymmetry requirement of `Ord` is not given. Only one of a < c and c < a is allowed to be"},{"DocComment":" // true, not both or neither."},{"DocComment":" assert_eq!((a < c) as u8 + (c < a) as u8, 2);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The documentation of [`PartialOrd`] contains further examples, for example it's wrong for"},{"DocComment":" [`PartialOrd`] and [`PartialEq`] to disagree."},{"DocComment":""},{"DocComment":" [`cmp`]: Ord::cmp"},{"Unknown":{"path":"doc","args":"alias = \"<\""}},{"Unknown":{"path":"doc","args":"alias = \">\""}},{"Unknown":{"path":"doc","args":"alias = \"<=\""}},{"Unknown":{"path":"doc","args":"alias = \">=\""}},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"Ord\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Ord"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[{"clause_id":0,"span":{"span":{"file_id":19,"beg":{"line":960,"col":15},"end":{"line":960,"col":17}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":5,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}},{"clause_id":1,"span":{"span":{"file_id":19,"beg":{"line":960,"col":20},"end":{"line":960,"col":36}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":13,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["cmp",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":50,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":15,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[15,"cmp"]}}]],"vtable":null},{"def_id":16,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["adapters",0]},{"Ident":["zip",0]},{"Ident":["TrustedRandomAccessNoCoerce",0]}],"span":{"span":{"file_id":25,"beg":{"line":593,"col":0},"end":{"line":593,"col":51}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Like [`TrustedRandomAccess`] but without any of the requirements / guarantees around"},{"DocComment":" coercions to supertypes after `__iterator_get_unchecked` (they aren’t allowed here!), and"},{"DocComment":" without the requirement that subtypes / supertypes implement `TrustedRandomAccessNoCoerce`."},{"DocComment":""},{"DocComment":" This trait was created in PR #85874 to fix soundness issue #85873 without performance regressions."},{"DocComment":" It is subject to change as we might want to build a more generally useful (for performance"},{"DocComment":" optimizations) and more sophisticated trait or trait hierarchy that replaces or extends"},{"DocComment":" [`TrustedRandomAccess`] and `TrustedRandomAccessNoCoerce`."},{"Unknown":{"path":"doc","args":"hidden"}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[["MAY_HAVE_SIDE_EFFECT",{"Literal":"Bool"}]],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[],"vtable":null},{"def_id":17,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnMut",0]}],"span":{"span":{"file_id":27,"beg":{"line":163,"col":0},"end":{"line":163,"col":42}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The version of the call operator that takes a mutable receiver."},{"DocComment":""},{"DocComment":" Instances of `FnMut` can be called repeatedly and may mutate state."},{"DocComment":""},{"DocComment":" `FnMut` is implemented automatically by closures which take mutable"},{"DocComment":" references to captured variables, as well as all types that implement"},{"DocComment":" [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of"},{"DocComment":" [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`"},{"DocComment":" implements `FnMut`, too."},{"DocComment":""},{"DocComment":" Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be"},{"DocComment":" used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of"},{"DocComment":" `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected."},{"DocComment":""},{"DocComment":" Use `FnMut` as a bound when you want to accept a parameter of function-like"},{"DocComment":" type and need to call it repeatedly, while allowing it to mutate state."},{"DocComment":" If you don't want the parameter to mutate state, use [`Fn`] as a"},{"DocComment":" bound; if you don't need to call it repeatedly, use [`FnOnce`]."},{"DocComment":""},{"DocComment":" See the [chapter on closures in *The Rust Programming Language*][book] for"},{"DocComment":" some more information on this topic."},{"DocComment":""},{"DocComment":" Also of note is the special syntax for `Fn` traits (e.g."},{"DocComment":" `Fn(usize, bool) -> usize`). Those interested in the technical details of"},{"DocComment":" this can refer to [the relevant section in the *Rustonomicon*][nomicon]."},{"DocComment":""},{"DocComment":" [book]: ../../book/ch13-01-closures.html"},{"DocComment":" [function pointers]: fn"},{"DocComment":" [nomicon]: ../../nomicon/hrtb.html"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ## Calling a mutably capturing closure"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let mut x = 5;"},{"DocComment":" {"},{"DocComment":"     let mut square_x = || x *= x;"},{"DocComment":"     square_x();"},{"DocComment":" }"},{"DocComment":" assert_eq!(x, 25);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Using a `FnMut` parameter"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" fn do_twice<F>(mut func: F)"},{"DocComment":"     where F: FnMut()"},{"DocComment":" {"},{"DocComment":"     func();"},{"DocComment":"     func();"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let mut x: usize = 1;"},{"DocComment":" {"},{"DocComment":"     let add_two_to_x = || x += 2;"},{"DocComment":"     do_twice(add_two_to_x);"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" assert_eq!(x, 5);"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(Args = \"()\", note =\n\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"),\non(Self = \"unsafe fn\", note =\n\"unsafe function cannot be called generically without an unsafe block\", label\n= \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"), message =\n\"expected a `{Trait}` closure, found `{Self}`\", label =\n\"expected an `{Trait}` closure, found `{Self}`\""}},{"Unknown":{"path":"fundamental","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"fn_mut"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Args"},{"index":2,"name":"Self_Clause1_Output"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":27,"beg":{"line":163,"col":30},"end":{"line":163,"col":42}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":18,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}},null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["call_mut",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":133,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":17,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[17,"call_mut"]}}]],"vtable":null},{"def_id":18,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["function",0]},{"Ident":["FnOnce",0]}],"span":{"span":{"file_id":27,"beg":{"line":242,"col":0},"end":{"line":242,"col":29}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The version of the call operator that takes a by-value receiver."},{"DocComment":""},{"DocComment":" Instances of `FnOnce` can be called, but might not be callable multiple"},{"DocComment":" times. Because of this, if the only thing known about a type is that it"},{"DocComment":" implements `FnOnce`, it can only be called once."},{"DocComment":""},{"DocComment":" `FnOnce` is implemented automatically by closures that might consume captured"},{"DocComment":" variables, as well as all types that implement [`FnMut`], e.g., (safe)"},{"DocComment":" [function pointers] (since `FnOnce` is a supertrait of [`FnMut`])."},{"DocComment":""},{"DocComment":" Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of"},{"DocComment":" [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected."},{"DocComment":""},{"DocComment":" Use `FnOnce` as a bound when you want to accept a parameter of function-like"},{"DocComment":" type and only need to call it once. If you need to call the parameter"},{"DocComment":" repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate"},{"DocComment":" state, use [`Fn`]."},{"DocComment":""},{"DocComment":" See the [chapter on closures in *The Rust Programming Language*][book] for"},{"DocComment":" some more information on this topic."},{"DocComment":""},{"DocComment":" Also of note is the special syntax for `Fn` traits (e.g."},{"DocComment":" `Fn(usize, bool) -> usize`). Those interested in the technical details of"},{"DocComment":" this can refer to [the relevant section in the *Rustonomicon*][nomicon]."},{"DocComment":""},{"DocComment":" [book]: ../../book/ch13-01-closures.html"},{"DocComment":" [function pointers]: fn"},{"DocComment":" [nomicon]: ../../nomicon/hrtb.html"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ## Using a `FnOnce` parameter"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" fn consume_with_relish<F>(func: F)"},{"DocComment":"     where F: FnOnce() -> String"},{"DocComment":" {"},{"DocComment":"     // `func` consumes its captured variables, so it cannot be run more"},{"DocComment":"     // than once."},{"DocComment":"     println!(\"Consumed: {}\", func());"},{"DocComment":""},{"DocComment":"     println!(\"Delicious!\");"},{"DocComment":""},{"DocComment":"     // Attempting to invoke `func()` again will throw a `use of moved"},{"DocComment":"     // value` error for `func`."},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let x = String::from(\"x\");"},{"DocComment":" let consume_and_return_x = move || x;"},{"DocComment":" consume_with_relish(consume_and_return_x);"},{"DocComment":""},{"DocComment":" // `consume_and_return_x` can no longer be invoked at this point"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(Args = \"()\", note =\n\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"),\non(Self = \"unsafe fn\", note =\n\"unsafe function cannot be called generically without an unsafe block\", label\n= \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"), message =\n\"expected a `{Trait}` closure, found `{Self}`\", label =\n\"expected an `{Trait}` closure, found `{Self}`\""}},{"Unknown":{"path":"fundamental","args":null}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"fn_once"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Args"},{"index":2,"name":"Self_Output"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null,null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["call_once",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":134,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":18,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[18,"call_once"]}}]],"vtable":null},{"def_id":19,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["FromIterator",0]}],"span":{"span":{"file_id":12,"beg":{"line":134,"col":0},"end":{"line":134,"col":32}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Conversion from an [`Iterator`]."},{"DocComment":""},{"DocComment":" By implementing `FromIterator` for a type, you define how it will be"},{"DocComment":" created from an iterator. This is common for types which describe a"},{"DocComment":" collection of some kind."},{"DocComment":""},{"DocComment":" If you want to create a collection from the contents of an iterator, the"},{"DocComment":" [`Iterator::collect()`] method is preferred. However, when you need to"},{"DocComment":" specify the container type, [`FromIterator::from_iter()`] can be more"},{"DocComment":" readable than using a turbofish (e.g. `::<Vec<_>>()`). See the"},{"DocComment":" [`Iterator::collect()`] documentation for more examples of its use."},{"DocComment":""},{"DocComment":" See also: [`IntoIterator`]."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let five_fives = std::iter::repeat(5).take(5);"},{"DocComment":""},{"DocComment":" let v = Vec::from_iter(five_fives);"},{"DocComment":""},{"DocComment":" assert_eq!(v, vec![5, 5, 5, 5, 5]);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Using [`Iterator::collect()`] to implicitly use `FromIterator`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let five_fives = std::iter::repeat(5).take(5);"},{"DocComment":""},{"DocComment":" let v: Vec<i32> = five_fives.collect();"},{"DocComment":""},{"DocComment":" assert_eq!(v, vec![5, 5, 5, 5, 5]);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Using [`FromIterator::from_iter()`] as a more readable alternative to"},{"DocComment":" [`Iterator::collect()`]:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::collections::VecDeque;"},{"DocComment":" let first = (0..10).collect::<VecDeque<i32>>();"},{"DocComment":" let second = VecDeque::from_iter(0..10);"},{"DocComment":""},{"DocComment":" assert_eq!(first, second);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Implementing `FromIterator` for your type:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // A sample collection, that's just a wrapper over Vec<T>"},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct MyCollection(Vec<i32>);"},{"DocComment":""},{"DocComment":" // Let's give it some methods so we can create one and add things"},{"DocComment":" // to it."},{"DocComment":" impl MyCollection {"},{"DocComment":"     fn new() -> MyCollection {"},{"DocComment":"         MyCollection(Vec::new())"},{"DocComment":"     }"},{"DocComment":""},{"DocComment":"     fn add(&mut self, elem: i32) {"},{"DocComment":"         self.0.push(elem);"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // and we'll implement FromIterator"},{"DocComment":" impl FromIterator<i32> for MyCollection {"},{"DocComment":"     fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {"},{"DocComment":"         let mut c = MyCollection::new();"},{"DocComment":""},{"DocComment":"         for i in iter {"},{"DocComment":"             c.add(i);"},{"DocComment":"         }"},{"DocComment":""},{"DocComment":"         c"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // Now we can make a new iterator..."},{"DocComment":" let iter = (0..5).into_iter();"},{"DocComment":""},{"DocComment":" // ... and make a MyCollection out of it"},{"DocComment":" let c = MyCollection::from_iter(iter);"},{"DocComment":""},{"DocComment":" assert_eq!(c.0, vec![0, 1, 2, 3, 4]);"},{"DocComment":""},{"DocComment":" // collect works too!"},{"DocComment":""},{"DocComment":" let iter = (0..5).into_iter();"},{"DocComment":" let c: MyCollection = iter.collect();"},{"DocComment":""},{"DocComment":" assert_eq!(c.0, vec![0, 1, 2, 3, 4]);"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(Self = \"&[{A}]\", message =\n\"a slice of type `{Self}` cannot be built since we need to store the elements somewhere\",\nlabel = \"try explicitly collecting into a `Vec<{A}>`\",),\non(all(A = \"{integer}\", any(Self = \"&[{integral}]\",)), message =\n\"a slice of type `{Self}` cannot be built since we need to store the elements somewhere\",\nlabel = \"try explicitly collecting into a `Vec<{A}>`\",),\non(Self = \"[{A}]\", message =\n\"a slice of type `{Self}` cannot be built since `{Self}` has no definite size\",\nlabel = \"try explicitly collecting into a `Vec<{A}>`\",),\non(all(A = \"{integer}\", any(Self = \"[{integral}]\",)), message =\n\"a slice of type `{Self}` cannot be built since `{Self}` has no definite size\",\nlabel = \"try explicitly collecting into a `Vec<{A}>`\",),\non(Self = \"[{A}; _]\", message =\n\"an array of type `{Self}` cannot be built directly from an iterator\", label =\n\"try collecting into a `Vec<{A}>`, then using `.try_into()`\",),\non(all(A = \"{integer}\", any(Self = \"[{integral}; _]\",)), message =\n\"an array of type `{Self}` cannot be built directly from an iterator\", label =\n\"try collecting into a `Vec<{A}>`, then using `.try_into()`\",), message =\n\"a value of type `{Self}` cannot be built from an iterator \\\n               over elements of type `{A}`\",\nlabel =\n\"value of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\""}},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"FromIterator\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"FromIterator"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["from_iter",{"params":{"regions":[],"types":[{"index":0,"name":"T"},{"index":1,"name":"Clause1_IntoIter"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":12,"beg":{"line":152,"col":20},"end":{"line":152,"col":42}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[1,1]}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[null]},"skip_binder":{"id":138,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[0,0]}},{"TypeVar":{"Bound":[0,1]}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":19,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}},null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[1,1]}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[19,"from_iter"]}}]],"vtable":null},{"def_id":20,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Try",0]}],"span":{"span":{"file_id":28,"beg":{"line":131,"col":0},"end":{"line":131,"col":27}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The `?` operator and `try {}` blocks."},{"DocComment":""},{"DocComment":" `try_*` methods typically involve a type implementing this trait.  For"},{"DocComment":" example, the closures passed to [`Iterator::try_fold`] and"},{"DocComment":" [`Iterator::try_for_each`] must return such a type."},{"DocComment":""},{"DocComment":" `Try` types are typically those containing two or more categories of values,"},{"DocComment":" some subset of which are so commonly handled via early returns that it's"},{"DocComment":" worth providing a terse (but still visible) syntax to make that easy."},{"DocComment":""},{"DocComment":" This is most often seen for error handling with [`Result`] and [`Option`]."},{"DocComment":" The quintessential implementation of this trait is on [`ControlFlow`]."},{"DocComment":""},{"DocComment":" # Using `Try` in Generic Code"},{"DocComment":""},{"DocComment":" `Iterator::try_fold` was stabilized to call back in Rust 1.27, but"},{"DocComment":" this trait is much newer.  To illustrate the various associated types and"},{"DocComment":" methods, let's implement our own version."},{"DocComment":""},{"DocComment":" As a reminder, an infallible version of a fold looks something like this:"},{"DocComment":" ```"},{"DocComment":" fn simple_fold<A, T>("},{"DocComment":"     iter: impl Iterator<Item = T>,"},{"DocComment":"     mut accum: A,"},{"DocComment":"     mut f: impl FnMut(A, T) -> A,"},{"DocComment":" ) -> A {"},{"DocComment":"     for x in iter {"},{"DocComment":"         accum = f(accum, x);"},{"DocComment":"     }"},{"DocComment":"     accum"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" So instead of `f` returning just an `A`, we'll need it to return some other"},{"DocComment":" type that produces an `A` in the \"don't short circuit\" path.  Conveniently,"},{"DocComment":" that's also the type we need to return from the function."},{"DocComment":""},{"DocComment":" Let's add a new generic parameter `R` for that type, and bound it to the"},{"DocComment":" output type that we want:"},{"DocComment":" ```"},{"DocComment":" # #![feature(try_trait_v2)]"},{"DocComment":" # use std::ops::Try;"},{"DocComment":" fn simple_try_fold_1<A, T, R: Try<Output = A>>("},{"DocComment":"     iter: impl Iterator<Item = T>,"},{"DocComment":"     mut accum: A,"},{"DocComment":"     mut f: impl FnMut(A, T) -> R,"},{"DocComment":" ) -> R {"},{"DocComment":"     todo!()"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" If we get through the entire iterator, we need to wrap up the accumulator"},{"DocComment":" into the return type using [`Try::from_output`]:"},{"DocComment":" ```"},{"DocComment":" # #![feature(try_trait_v2)]"},{"DocComment":" # use std::ops::{ControlFlow, Try};"},{"DocComment":" fn simple_try_fold_2<A, T, R: Try<Output = A>>("},{"DocComment":"     iter: impl Iterator<Item = T>,"},{"DocComment":"     mut accum: A,"},{"DocComment":"     mut f: impl FnMut(A, T) -> R,"},{"DocComment":" ) -> R {"},{"DocComment":"     for x in iter {"},{"DocComment":"         let cf = f(accum, x).branch();"},{"DocComment":"         match cf {"},{"DocComment":"             ControlFlow::Continue(a) => accum = a,"},{"DocComment":"             ControlFlow::Break(_) => todo!(),"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":"     R::from_output(accum)"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" We'll also need [`FromResidual::from_residual`] to turn the residual back"},{"DocComment":" into the original type.  But because it's a supertrait of `Try`, we don't"},{"DocComment":" need to mention it in the bounds.  All types which implement `Try` can be"},{"DocComment":" recreated from their corresponding residual, so we'll just call it:"},{"DocComment":" ```"},{"DocComment":" # #![feature(try_trait_v2)]"},{"DocComment":" # use std::ops::{ControlFlow, Try};"},{"DocComment":" pub fn simple_try_fold_3<A, T, R: Try<Output = A>>("},{"DocComment":"     iter: impl Iterator<Item = T>,"},{"DocComment":"     mut accum: A,"},{"DocComment":"     mut f: impl FnMut(A, T) -> R,"},{"DocComment":" ) -> R {"},{"DocComment":"     for x in iter {"},{"DocComment":"         let cf = f(accum, x).branch();"},{"DocComment":"         match cf {"},{"DocComment":"             ControlFlow::Continue(a) => accum = a,"},{"DocComment":"             ControlFlow::Break(r) => return R::from_residual(r),"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":"     R::from_output(accum)"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" But this \"call `branch`, then `match` on it, and `return` if it was a"},{"DocComment":" `Break`\" is exactly what happens inside the `?` operator.  So rather than"},{"DocComment":" do all this manually, we can just use `?` instead:"},{"DocComment":" ```"},{"DocComment":" # #![feature(try_trait_v2)]"},{"DocComment":" # use std::ops::Try;"},{"DocComment":" fn simple_try_fold<A, T, R: Try<Output = A>>("},{"DocComment":"     iter: impl Iterator<Item = T>,"},{"DocComment":"     mut accum: A,"},{"DocComment":"     mut f: impl FnMut(A, T) -> R,"},{"DocComment":" ) -> R {"},{"DocComment":"     for x in iter {"},{"DocComment":"         accum = f(accum, x)?;"},{"DocComment":"     }"},{"DocComment":"     R::from_output(accum)"},{"DocComment":" }"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(all(from_desugaring = \"TryBlock\"), message =\n\"a `try` block must return `Result` or `Option` \\\n                    (or another type that implements `{This}`)\",\nlabel =\n\"could not wrap the final value of the block as `{Self}` doesn't implement `Try`\",),\non(all(from_desugaring = \"QuestionMark\"), message =\n\"the `?` operator can only be applied to values that implement `{This}`\",\nlabel = \"the `?` operator cannot be applied to type `{Self}`\")"}},{"Unknown":{"path":"doc","args":"alias = \"?\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Try"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Self_Output"},{"index":2,"name":"Self_Residual"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":28,"beg":{"line":131,"col":15},"end":{"line":131,"col":27}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":30,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}},null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["from_output",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":135,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":20,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[20,"from_output"]}}],["branch",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":136,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":20,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":2}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[20,"branch"]}}]],"vtable":null},{"def_id":21,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["Residual",0]}],"span":{"span":{"file_id":28,"beg":{"line":360,"col":0},"end":{"line":360,"col":21}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Allows retrieving the canonical type implementing [`Try`] that has this type"},{"DocComment":" as its residual and allows it to hold an `O` as its output."},{"DocComment":""},{"DocComment":" If you think of the `Try` trait as splitting a type into its [`Try::Output`]"},{"DocComment":" and [`Try::Residual`] components, this allows putting them back together."},{"DocComment":""},{"DocComment":" For example,"},{"DocComment":" `Result<T, E>: Try<Output = T, Residual = Result<Infallible, E>>`,"},{"DocComment":" and in the other direction,"},{"DocComment":" `<Result<Infallible, E> as Residual<T>>::TryType = Result<T, E>`."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"O"},{"index":2,"name":"Self_TryType"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[null,null]},"parent_clauses":[null,null,null,{"clause_id":3,"span":{"span":{"file_id":28,"beg":{"line":363,"col":18},"end":{"line":363,"col":50}},"generated_from_span":null},"origin":{"TraitItem":"TryType"},"trait_":{"regions":[],"skip_binder":{"id":20,"generics":{"regions":[],"types":[{"TypeVar":{"Free":2}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[],"vtable":null},{"def_id":22,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Ident":["Extend",0]}],"span":{"span":{"file_id":12,"beg":{"line":394,"col":0},"end":{"line":394,"col":19}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Extend a collection with the contents of an iterator."},{"DocComment":""},{"DocComment":" Iterators produce a series of values, and collections can also be thought"},{"DocComment":" of as a series of values. The `Extend` trait bridges this gap, allowing you"},{"DocComment":" to extend a collection by including the contents of that iterator. When"},{"DocComment":" extending a collection with an already existing key, that entry is updated"},{"DocComment":" or, in the case of collections that permit multiple entries with equal"},{"DocComment":" keys, that entry is inserted."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // You can extend a String with some chars:"},{"DocComment":" let mut message = String::from(\"The first three letters are: \");"},{"DocComment":""},{"DocComment":" message.extend(&['a', 'b', 'c']);"},{"DocComment":""},{"DocComment":" assert_eq!(\"abc\", &message[29..32]);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Implementing `Extend`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // A sample collection, that's just a wrapper over Vec<T>"},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct MyCollection(Vec<i32>);"},{"DocComment":""},{"DocComment":" // Let's give it some methods so we can create one and add things"},{"DocComment":" // to it."},{"DocComment":" impl MyCollection {"},{"DocComment":"     fn new() -> MyCollection {"},{"DocComment":"         MyCollection(Vec::new())"},{"DocComment":"     }"},{"DocComment":""},{"DocComment":"     fn add(&mut self, elem: i32) {"},{"DocComment":"         self.0.push(elem);"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // since MyCollection has a list of i32s, we implement Extend for i32"},{"DocComment":" impl Extend<i32> for MyCollection {"},{"DocComment":""},{"DocComment":"     // This is a bit simpler with the concrete type signature: we can call"},{"DocComment":"     // extend on anything which can be turned into an Iterator which gives"},{"DocComment":"     // us i32s. Because we need i32s to put into MyCollection."},{"DocComment":"     fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {"},{"DocComment":""},{"DocComment":"         // The implementation is very straightforward: loop through the"},{"DocComment":"         // iterator, and add() each element to ourselves."},{"DocComment":"         for elem in iter {"},{"DocComment":"             self.add(elem);"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" let mut c = MyCollection::new();"},{"DocComment":""},{"DocComment":" c.add(5);"},{"DocComment":" c.add(6);"},{"DocComment":" c.add(7);"},{"DocComment":""},{"DocComment":" // let's extend our collection with three more numbers"},{"DocComment":" c.extend(vec![1, 2, 3]);"},{"DocComment":""},{"DocComment":" // we've added these elements onto the end"},{"DocComment":" assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{c:?}\"));"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["extend",{"params":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"T"},{"index":1,"name":"Clause1_IntoIter"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":12,"beg":{"line":413,"col":17},"end":{"line":413,"col":39}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[1,1]}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[null]},"skip_binder":{"id":139,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[0,0]}},{"TypeVar":{"Bound":[0,1]}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":22,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}},null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[1,1]}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[22,"extend"]}}]],"vtable":null},{"def_id":23,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["default",0]},{"Ident":["Default",0]}],"span":{"span":{"file_id":29,"beg":{"line":106,"col":0},"end":{"line":106,"col":24}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" A trait for giving a type a useful default value."},{"DocComment":""},{"DocComment":" Sometimes, you want to fall back to some kind of default value, and"},{"DocComment":" don't particularly care what it is. This comes up often with `struct`s"},{"DocComment":" that define a set of options:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" struct SomeOptions {"},{"DocComment":"     foo: i32,"},{"DocComment":"     bar: f32,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" How can we define some default values? You can use `Default`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" #[derive(Default)]"},{"DocComment":" struct SomeOptions {"},{"DocComment":"     foo: i32,"},{"DocComment":"     bar: f32,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" fn main() {"},{"DocComment":"     let options: SomeOptions = Default::default();"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Now, you get all of the default values. Rust implements `Default` for various primitives types."},{"DocComment":""},{"DocComment":" If you want to override a particular option, but still retain the other defaults:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" # #[derive(Default)]"},{"DocComment":" # struct SomeOptions {"},{"DocComment":" #     foo: i32,"},{"DocComment":" #     bar: f32,"},{"DocComment":" # }"},{"DocComment":" fn main() {"},{"DocComment":"     let options = SomeOptions { foo: 42, ..Default::default() };"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## Derivable"},{"DocComment":""},{"DocComment":" This trait can be used with `#[derive]` if all of the type's fields implement"},{"DocComment":" `Default`. When `derive`d, it will use the default value for each field's type."},{"DocComment":""},{"DocComment":" ### `enum`s"},{"DocComment":""},{"DocComment":" When using `#[derive(Default)]` on an `enum`, you need to choose which unit variant will be"},{"DocComment":" default. You do this by placing the `#[default]` attribute on the variant."},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Default)]"},{"DocComment":" enum Kind {"},{"DocComment":"     #[default]"},{"DocComment":"     A,"},{"DocComment":"     B,"},{"DocComment":"     C,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" You cannot use the `#[default]` attribute on non-unit or non-exhaustive variants."},{"DocComment":""},{"DocComment":" The `#[default]` attribute was stabilized in Rust 1.62.0."},{"DocComment":""},{"DocComment":" ## How can I implement `Default`?"},{"DocComment":""},{"DocComment":" Provide an implementation for the `default()` method that returns the value of"},{"DocComment":" your type that should be the default:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(dead_code)]"},{"DocComment":" enum Kind {"},{"DocComment":"     A,"},{"DocComment":"     B,"},{"DocComment":"     C,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Default for Kind {"},{"DocComment":"     fn default() -> Self { Kind::A }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" #[derive(Default)]"},{"DocComment":" struct SomeOptions {"},{"DocComment":"     foo: i32,"},{"DocComment":"     bar: f32,"},{"DocComment":" }"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"Default\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"Default"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["default",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":132,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":23,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[23,"default"]}}]],"vtable":null},{"def_id":24,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["double_ended",0]},{"Ident":["DoubleEndedIterator",0]}],"span":{"span":{"file_id":30,"beg":{"line":41,"col":0},"end":{"line":41,"col":39}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" An iterator able to yield elements from both ends."},{"DocComment":""},{"DocComment":" Something that implements `DoubleEndedIterator` has one extra capability"},{"DocComment":" over something that implements [`Iterator`]: the ability to also take"},{"DocComment":" `Item`s from the back, as well as the front."},{"DocComment":""},{"DocComment":" It is important to note that both back and forth work on the same range,"},{"DocComment":" and do not cross: iteration is over when they meet in the middle."},{"DocComment":""},{"DocComment":" In a similar fashion to the [`Iterator`] protocol, once a"},{"DocComment":" `DoubleEndedIterator` returns [`None`] from a [`next_back()`], calling it"},{"DocComment":" again may or may not ever return [`Some`] again. [`next()`] and"},{"DocComment":" [`next_back()`] are interchangeable for this purpose."},{"DocComment":""},{"DocComment":" [`next_back()`]: DoubleEndedIterator::next_back"},{"DocComment":" [`next()`]: Iterator::next"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" let numbers = vec![1, 2, 3, 4, 5, 6];"},{"DocComment":""},{"DocComment":" let mut iter = numbers.iter();"},{"DocComment":""},{"DocComment":" assert_eq!(Some(&1), iter.next());"},{"DocComment":" assert_eq!(Some(&6), iter.next_back());"},{"DocComment":" assert_eq!(Some(&5), iter.next_back());"},{"DocComment":" assert_eq!(Some(&2), iter.next());"},{"DocComment":" assert_eq!(Some(&3), iter.next());"},{"DocComment":" assert_eq!(Some(&4), iter.next());"},{"DocComment":" assert_eq!(None, iter.next());"},{"DocComment":" assert_eq!(None, iter.next_back());"},{"DocComment":" ```"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"DoubleEndedIterator\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"DoubleEndedIterator"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Self_Clause1_Item"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":30,"beg":{"line":41,"col":31},"end":{"line":41,"col":39}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["next_back",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":143,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":24,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[24,"next_back"]}}]],"vtable":null},{"def_id":25,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["exact_size",0]},{"Ident":["ExactSizeIterator",0]}],"span":{"span":{"file_id":31,"beg":{"line":86,"col":0},"end":{"line":86,"col":37}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" An iterator that knows its exact length."},{"DocComment":""},{"DocComment":" Many [`Iterator`]s don't know how many times they will iterate, but some do."},{"DocComment":" If an iterator knows how many times it can iterate, providing access to"},{"DocComment":" that information can be useful. For example, if you want to iterate"},{"DocComment":" backwards, a good start is to know where the end is."},{"DocComment":""},{"DocComment":" When implementing an `ExactSizeIterator`, you must also implement"},{"DocComment":" [`Iterator`]. When doing so, the implementation of [`Iterator::size_hint`]"},{"DocComment":" *must* return the exact size of the iterator."},{"DocComment":""},{"DocComment":" The [`len`] method has a default implementation, so you usually shouldn't"},{"DocComment":" implement it. However, you may be able to provide a more performant"},{"DocComment":" implementation than the default, so overriding it in this case makes sense."},{"DocComment":""},{"DocComment":" Note that this trait is a safe trait and as such does *not* and *cannot*"},{"DocComment":" guarantee that the returned length is correct. This means that `unsafe`"},{"DocComment":" code **must not** rely on the correctness of [`Iterator::size_hint`]. The"},{"DocComment":" unstable and unsafe [`TrustedLen`](super::marker::TrustedLen) trait gives"},{"DocComment":" this additional guarantee."},{"DocComment":""},{"DocComment":" [`len`]: ExactSizeIterator::len"},{"DocComment":""},{"DocComment":" # When *shouldn't* an adapter be `ExactSizeIterator`?"},{"DocComment":""},{"DocComment":" If an adapter makes an iterator *longer*, then it's usually incorrect for"},{"DocComment":" that adapter to implement `ExactSizeIterator`.  The inner exact-sized"},{"DocComment":" iterator might already be `usize::MAX`-long, and thus the length of the"},{"DocComment":" longer adapted iterator would no longer be exactly representable in `usize`."},{"DocComment":""},{"DocComment":" This is why [`Chain<A, B>`](crate::iter::Chain) isn't `ExactSizeIterator`,"},{"DocComment":" even when `A` and `B` are both `ExactSizeIterator`."},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" Basic usage:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // a finite range knows exactly how many times it will iterate"},{"DocComment":" let five = 0..5;"},{"DocComment":""},{"DocComment":" assert_eq!(5, five.len());"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" In the [module-level docs], we implemented an [`Iterator`], `Counter`."},{"DocComment":" Let's implement `ExactSizeIterator` for it as well:"},{"DocComment":""},{"DocComment":" [module-level docs]: crate::iter"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # struct Counter {"},{"DocComment":" #     count: usize,"},{"DocComment":" # }"},{"DocComment":" # impl Counter {"},{"DocComment":" #     fn new() -> Counter {"},{"DocComment":" #         Counter { count: 0 }"},{"DocComment":" #     }"},{"DocComment":" # }"},{"DocComment":" # impl Iterator for Counter {"},{"DocComment":" #     type Item = usize;"},{"DocComment":" #     fn next(&mut self) -> Option<Self::Item> {"},{"DocComment":" #         self.count += 1;"},{"DocComment":" #         if self.count < 6 {"},{"DocComment":" #             Some(self.count)"},{"DocComment":" #         } else {"},{"DocComment":" #             None"},{"DocComment":" #         }"},{"DocComment":" #     }"},{"DocComment":" # }"},{"DocComment":" impl ExactSizeIterator for Counter {"},{"DocComment":"     // We can easily calculate the remaining number of iterations."},{"DocComment":"     fn len(&self) -> usize {"},{"DocComment":"         5 - self.count"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" // And now we can use it!"},{"DocComment":""},{"DocComment":" let mut counter = Counter::new();"},{"DocComment":""},{"DocComment":" assert_eq!(5, counter.len());"},{"DocComment":" let _ = counter.next();"},{"DocComment":" assert_eq!(4, counter.len());"},{"DocComment":" ```"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"Self_Clause1_Item"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":31,"beg":{"line":86,"col":29},"end":{"line":86,"col":37}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[],"vtable":null},{"def_id":26,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Copy",0]}],"span":{"span":{"file_id":7,"beg":{"line":461,"col":0},"end":{"line":461,"col":21}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Types whose values can be duplicated simply by copying bits."},{"DocComment":""},{"DocComment":" By default, variable bindings have 'move semantics.' In other"},{"DocComment":" words:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Debug)]"},{"DocComment":" struct Foo;"},{"DocComment":""},{"DocComment":" let x = Foo;"},{"DocComment":""},{"DocComment":" let y = x;"},{"DocComment":""},{"DocComment":" // `x` has moved into `y`, and so cannot be used"},{"DocComment":""},{"DocComment":" // println!(\"{x:?}\"); // error: use of moved value"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" However, if a type implements `Copy`, it instead has 'copy semantics':"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" // We can derive a `Copy` implementation. `Clone` is also required, as it's"},{"DocComment":" // a supertrait of `Copy`."},{"DocComment":" #[derive(Debug, Copy, Clone)]"},{"DocComment":" struct Foo;"},{"DocComment":""},{"DocComment":" let x = Foo;"},{"DocComment":""},{"DocComment":" let y = x;"},{"DocComment":""},{"DocComment":" // `y` is a copy of `x`"},{"DocComment":""},{"DocComment":" println!(\"{x:?}\"); // A-OK!"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" It's important to note that in these two examples, the only difference is whether you"},{"DocComment":" are allowed to access `x` after the assignment. Under the hood, both a copy and a move"},{"DocComment":" can result in bits being copied in memory, although this is sometimes optimized away."},{"DocComment":""},{"DocComment":" ## How can I implement `Copy`?"},{"DocComment":""},{"DocComment":" There are two ways to implement `Copy` on your type. The simplest is to use `derive`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct MyStruct;"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" You can also implement `Copy` and `Clone` manually:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" struct MyStruct;"},{"DocComment":""},{"DocComment":" impl Copy for MyStruct { }"},{"DocComment":""},{"DocComment":" impl Clone for MyStruct {"},{"DocComment":"     fn clone(&self) -> MyStruct {"},{"DocComment":"         *self"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" There is a small difference between the two. The `derive` strategy will also place a `Copy`"},{"DocComment":" bound on type parameters:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" #[derive(Clone)]"},{"DocComment":" struct MyStruct<T>(T);"},{"DocComment":""},{"DocComment":" impl<T: Copy> Copy for MyStruct<T> { }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" This isn't always desired. For example, shared references (`&T`) can be copied regardless of"},{"DocComment":" whether `T` is `Copy`. Likewise, a generic struct containing markers such as [`PhantomData`]"},{"DocComment":" could potentially be duplicated with a bit-wise copy."},{"DocComment":""},{"DocComment":" ## What's the difference between `Copy` and `Clone`?"},{"DocComment":""},{"DocComment":" Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of"},{"DocComment":" `Copy` is not overloadable; it is always a simple bit-wise copy."},{"DocComment":""},{"DocComment":" Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`] can"},{"DocComment":" provide any type-specific behavior necessary to duplicate values safely. For example,"},{"DocComment":" the implementation of [`Clone`] for [`String`] needs to copy the pointed-to string"},{"DocComment":" buffer in the heap. A simple bitwise copy of [`String`] values would merely copy the"},{"DocComment":" pointer, leading to a double free down the line. For this reason, [`String`] is [`Clone`]"},{"DocComment":" but not `Copy`."},{"DocComment":""},{"DocComment":" [`Clone`] is a supertrait of `Copy`, so everything which is `Copy` must also implement"},{"DocComment":" [`Clone`]. If a type is `Copy` then its [`Clone`] implementation only needs to return `*self`"},{"DocComment":" (see the example above)."},{"DocComment":""},{"DocComment":" ## When can my type be `Copy`?"},{"DocComment":""},{"DocComment":" A type can implement `Copy` if all of its components implement `Copy`. For example, this"},{"DocComment":" struct can be `Copy`:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #[allow(dead_code)]"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct Point {"},{"DocComment":"    x: i32,"},{"DocComment":"    y: i32,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" A struct can be `Copy`, and [`i32`] is `Copy`, therefore `Point` is eligible to be `Copy`."},{"DocComment":" By contrast, consider"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(dead_code)]"},{"DocComment":" # struct Point;"},{"DocComment":" struct PointList {"},{"DocComment":"     points: Vec<Point>,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we"},{"DocComment":" attempt to derive a `Copy` implementation, we'll get an error:"},{"DocComment":""},{"DocComment":" ```text"},{"DocComment":" the trait `Copy` cannot be implemented for this type; field `points` does not implement `Copy`"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Shared references (`&T`) are also `Copy`, so a type can be `Copy`, even when it holds"},{"DocComment":" shared references of types `T` that are *not* `Copy`. Consider the following struct,"},{"DocComment":" which can implement `Copy`, because it only holds a *shared reference* to our non-`Copy`"},{"DocComment":" type `PointList` from above:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" # #![allow(dead_code)]"},{"DocComment":" # struct PointList;"},{"DocComment":" #[derive(Copy, Clone)]"},{"DocComment":" struct PointListWrapper<'a> {"},{"DocComment":"     point_list_ref: &'a PointList,"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## When *can't* my type be `Copy`?"},{"DocComment":""},{"DocComment":" Some types can't be copied safely. For example, copying `&mut T` would create an aliased"},{"DocComment":" mutable reference. Copying [`String`] would duplicate responsibility for managing the"},{"DocComment":" [`String`]'s buffer, leading to a double free."},{"DocComment":""},{"DocComment":" Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's"},{"DocComment":" managing some resource besides its own [`size_of::<T>`] bytes."},{"DocComment":""},{"DocComment":" If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get"},{"DocComment":" the error [E0204]."},{"DocComment":""},{"DocComment":" [E0204]: ../../error_codes/E0204.html"},{"DocComment":""},{"DocComment":" ## When *should* my type be `Copy`?"},{"DocComment":""},{"DocComment":" Generally speaking, if your type _can_ implement `Copy`, it should. Keep in mind, though,"},{"DocComment":" that implementing `Copy` is part of the public API of your type. If the type might become"},{"DocComment":" non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to"},{"DocComment":" avoid a breaking API change."},{"DocComment":""},{"DocComment":" ## Additional implementors"},{"DocComment":""},{"DocComment":" In addition to the [implementors listed below][impls],"},{"DocComment":" the following types also implement `Copy`:"},{"DocComment":""},{"DocComment":" * Function item types (i.e., the distinct types defined for each function)"},{"DocComment":" * Function pointer types (e.g., `fn() -> i32`)"},{"DocComment":" * Closure types, if they capture no value from the environment"},{"DocComment":"   or if all such captured values implement `Copy` themselves."},{"DocComment":"   Note that variables captured by shared reference always implement `Copy`"},{"DocComment":"   (even if the referent doesn't),"},{"DocComment":"   while variables captured by mutable reference never implement `Copy`."},{"DocComment":""},{"DocComment":" [`Vec<T>`]: ../../std/vec/struct.Vec.html"},{"DocComment":" [`String`]: ../../std/string/struct.String.html"},{"DocComment":" [`size_of::<T>`]: size_of"},{"DocComment":" [impls]: #implementors"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"Copy\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"copy"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":7,"beg":{"line":461,"col":16},"end":{"line":461,"col":21}},"generated_from_span":null},"origin":"WhereClauseOnTrait","trait_":{"regions":[],"skip_binder":{"id":12,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[],"vtable":null},{"def_id":27,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Sum",0]}],"span":{"span":{"file_id":32,"beg":{"line":17,"col":0},"end":{"line":17,"col":30}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait to represent types that can be created by summing up an iterator."},{"DocComment":""},{"DocComment":" This trait is used to implement [`Iterator::sum()`]. Types which implement"},{"DocComment":" this trait can be generated by using the [`sum()`] method on an iterator."},{"DocComment":" Like [`FromIterator`], this trait should rarely be called directly."},{"DocComment":""},{"DocComment":" [`sum()`]: Iterator::sum"},{"DocComment":" [`FromIterator`]: iter::FromIterator"},{"Unknown":{"path":"diagnostic::on_unimplemented","args":"message =\n\"a value of type `{Self}` cannot be made by summing an iterator over elements of type `{A}`\",\nlabel =\n\"value of type `{Self}` cannot be made by summing a `std::iter::Iterator<Item={A}>`\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["sum",{"params":{"regions":[],"types":[{"index":0,"name":"I"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":32,"beg":{"line":21,"col":14},"end":{"line":21,"col":32}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[null]},"skip_binder":{"id":190,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":27,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}},null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[27,"sum"]}}]],"vtable":null},{"def_id":28,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["accum",0]},{"Ident":["Product",0]}],"span":{"span":{"file_id":32,"beg":{"line":38,"col":0},"end":{"line":38,"col":34}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Trait to represent types that can be created by multiplying elements of an"},{"DocComment":" iterator."},{"DocComment":""},{"DocComment":" This trait is used to implement [`Iterator::product()`]. Types which implement"},{"DocComment":" this trait can be generated by using the [`product()`] method on an iterator."},{"DocComment":" Like [`FromIterator`], this trait should rarely be called directly."},{"DocComment":""},{"DocComment":" [`product()`]: Iterator::product"},{"DocComment":" [`FromIterator`]: iter::FromIterator"},{"Unknown":{"path":"diagnostic::on_unimplemented","args":"message =\n\"a value of type `{Self}` cannot be made by multiplying all elements of type `{A}` from an iterator\",\nlabel =\n\"value of type `{Self}` cannot be made by multiplying all elements from a `std::iter::Iterator<Item={A}>`\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"A"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["product",{"params":{"regions":[],"types":[{"index":0,"name":"I"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":32,"beg":{"line":42,"col":18},"end":{"line":42,"col":36}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[null]},"skip_binder":{"id":191,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":28,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}},null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[28,"product"]}}]],"vtable":null},null,{"def_id":30,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["try_trait",0]},{"Ident":["FromResidual",0]}],"span":{"span":{"file_id":28,"beg":{"line":307,"col":0},"end":{"line":307,"col":51}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Used to specify which residuals can be converted into which [`crate::ops::Try`] types."},{"DocComment":""},{"DocComment":" Every `Try` type needs to be recreatable from its own associated"},{"DocComment":" `Residual` type, but can also have additional `FromResidual` implementations"},{"DocComment":" to support interconversion with other `Try` types."},{"Unknown":{"path":"rustc_on_unimplemented","args":"on(all(from_desugaring = \"QuestionMark\", Self = \"core::result::Result<T, E>\",\nR = \"core::option::Option<core::convert::Infallible>\",), message =\n\"the `?` operator can only be used on `Result`s, not `Option`s, \\\n            in {ItemContext} that returns `Result`\",\nlabel = \"use `.ok_or(...)?` to provide an error compatible with `{Self}`\",\nparent_label = \"this function returns a `Result`\"),\non(all(from_desugaring = \"QuestionMark\", Self =\n\"core::result::Result<T, E>\",), message =\n\"the `?` operator can only be used on `Result`s \\\n            in {ItemContext} that returns `Result`\",\nlabel = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\nparent_label = \"this function returns a `Result`\"),\non(all(from_desugaring = \"QuestionMark\", Self = \"core::option::Option<T>\", R =\n\"core::result::Result<T, E>\",), message =\n\"the `?` operator can only be used on `Option`s, not `Result`s, \\\n            in {ItemContext} that returns `Option`\",\nlabel = \"use `.ok()?` if you want to discard the `{R}` error information\",\nparent_label = \"this function returns an `Option`\"),\non(all(from_desugaring = \"QuestionMark\", Self = \"core::option::Option<T>\",),\nmessage =\n\"the `?` operator can only be used on `Option`s \\\n            in {ItemContext} that returns `Option`\",\nlabel = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\nparent_label = \"this function returns an `Option`\"),\non(all(from_desugaring = \"QuestionMark\", Self =\n\"core::ops::control_flow::ControlFlow<B, C>\", R =\n\"core::ops::control_flow::ControlFlow<B, C>\",), message =\n\"the `?` operator in {ItemContext} that returns `ControlFlow<B, _>` \\\n            can only be used on other `ControlFlow<B, _>`s (with the same Break type)\",\nlabel = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\nparent_label = \"this function returns a `ControlFlow`\", note =\n\"unlike `Result`, there's no `From`-conversion performed for `ControlFlow`\"),\non(all(from_desugaring = \"QuestionMark\", Self =\n\"core::ops::control_flow::ControlFlow<B, C>\",), message =\n\"the `?` operator can only be used on `ControlFlow`s \\\n            in {ItemContext} that returns `ControlFlow`\",\nlabel = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\nparent_label = \"this function returns a `ControlFlow`\",),\non(all(from_desugaring = \"QuestionMark\"), message =\n\"the `?` operator can only be used in {ItemContext} \\\n                    that returns `Result` or `Option` \\\n                    (or another type that implements `{This}`)\",\nlabel = \"cannot use the `?` operator in {ItemContext} that returns `{Self}`\",\nparent_label =\n\"this function should return `Result` or `Option` to accept `?`\"),"}},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"FromResidual\""}}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"FromResidual"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"},{"index":1,"name":"R"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null,null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["from_residual",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":137,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":30,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[30,"from_residual"]}}]],"vtable":null}],"trait_impls":[{"def_id":0,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":0}}],"span":{"span":{"file_id":9,"beg":{"line":21,"col":0},"end":{"line":21,"col":36}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":2,"generics":{"regions":[],"types":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Builtin":"Slice"},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}},"Shared"]},{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]},{"Adt":{"id":{"Adt":2},"generics":{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[{"index":0,"name":"'a"}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null,null,null,{"kind":{"TraitImpl":{"id":2,"generics":{"regions":["Erased"],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":2},"generics":{"regions":["Erased"],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}},{"Ref":["Erased",{"TypeVar":{"Free":0}},"Shared"]}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"types":[],"type_clauses":[],"methods":[["into_iter",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":168,"generics":{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}},"kind":{"TraitMethod":[2,"into_iter"]}}]],"vtable":null},null,{"def_id":2,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["slice",0]},{"Ident":["iter",0]},{"Impl":{"Trait":2}}],"span":{"span":{"file_id":18,"beg":{"line":152,"col":8},"end":{"line":152,"col":45}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":4,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":2},"generics":{"regions":[{"Var":{"Free":0}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}},{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Shared"]}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[{"index":0,"name":"'a"}],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null,null],"consts":[],"types":[],"type_clauses":[],"methods":[["next",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":194,"generics":{"regions":[{"Var":{"Free":0}},{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}},"kind":{"TraitMethod":[4,"next"]}}]],"vtable":null},{"def_id":3,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":3}}],"span":{"span":{"file_id":19,"beg":{"line":1841,"col":12},"end":{"line":1841,"col":26}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":5,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[{"kind":{"TraitImpl":{"id":11,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":11,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"types":[],"type_clauses":[],"methods":[],"vtable":null},{"def_id":4,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["hash",0]},{"Ident":["impls",0]},{"Impl":{"Trait":4}}],"span":{"span":{"file_id":20,"beg":{"line":809,"col":12},"end":{"line":809,"col":29}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":6,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[],"consts":[],"types":[],"type_clauses":[],"methods":[["hash",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[{"index":0,"name":"H"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":20,"beg":{"line":811,"col":27},"end":{"line":811,"col":33}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":192,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[{"TypeVar":{"Bound":[0,0]}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Bound":[0,1]}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"TypeVar":{"Bound":[1,0]}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[6,"hash"]}}]],"vtable":null},{"def_id":5,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":5}}],"span":{"span":{"file_id":5,"beg":{"line":81,"col":0},"end":{"line":81,"col":32}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":7,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null,null,{"kind":{"TraitImpl":{"id":10,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":10,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"types":[],"type_clauses":[],"methods":[["build_hasher",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":10,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[],"const_generics":[],"trait_refs":[]}},"kind":{"TraitMethod":[7,"build_hasher"]}}]],"vtable":null},{"def_id":6,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["borrow",0]},{"Impl":{"Trait":6}}],"span":{"span":{"file_id":21,"beg":{"line":209,"col":0},"end":{"line":209,"col":31}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":8,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null,null],"consts":[],"types":[],"type_clauses":[],"methods":[["borrow",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":18,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}},"kind":{"TraitMethod":[8,"borrow"]}}]],"vtable":{"id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}},{"def_id":7,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["traits",0]},{"Ident":["collect",0]},{"Impl":{"Trait":7}}],"span":{"span":{"file_id":12,"beg":{"line":314,"col":0},"end":{"line":314,"col":36}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":2,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[{"index":0,"name":"I"},{"index":1,"name":"Clause1_Item"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":12,"beg":{"line":314,"col":8},"end":{"line":314,"col":16}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null,null,null,{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"types":[],"type_clauses":[],"methods":[["into_iter",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":55,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":4,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[2,"into_iter"]}}]],"vtable":null},{"def_id":8,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":8}}],"span":{"span":{"file_id":23,"beg":{"line":845,"col":0},"end":{"line":845,"col":40}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":4,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":4},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null]}}},{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[{"index":0,"name":"A"}],"const_generics":[],"trait_clauses":[null,{"clause_id":1,"span":{"span":{"file_id":23,"beg":{"line":845,"col":8},"end":{"line":845,"col":12}},"generated_from_span":null},"origin":"WhereClauseOnImpl","trait_":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null,null],"consts":[],"types":[],"type_clauses":[],"methods":[["next",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":40,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null,{"kind":{"Clause":{"Free":1}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":9,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[4,"next"]}}]],"vtable":null},{"def_id":9,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["iter",0]},{"Ident":["range",0]},{"Impl":{"Trait":9}}],"span":{"span":{"file_id":23,"beg":{"line":258,"col":12},"end":{"line":258,"col":37}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":9,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null,{"kind":{"TraitImpl":{"id":12,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":12,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}}}},{"kind":{"TraitImpl":{"id":13,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":13,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}},{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"types":[],"type_clauses":[],"methods":[["steps_between",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":171,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[],"const_generics":[],"trait_refs":[]}},"kind":{"TraitMethod":[9,"steps_between"]}}],["forward_checked",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":172,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"kind":{"TraitMethod":[9,"forward_checked"]}}],["backward_checked",{"params":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":175,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},"kind":{"TraitMethod":[9,"backward_checked"]}}]],"vtable":null},{"def_id":10,"item_meta":{"name":[{"Ident":["std",0]},{"Ident":["hash",0]},{"Ident":["random",0]},{"Impl":{"Trait":10}}],"span":{"span":{"file_id":5,"beg":{"line":127,"col":0},"end":{"line":127,"col":29}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":10,"generics":{"regions":[],"types":[{"Adt":{"id":{"Adt":5},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null],"consts":[],"types":[],"type_clauses":[],"methods":[["finish",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":12,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[],"const_generics":[],"trait_refs":[]}},"kind":{"TraitMethod":[10,"finish"]}}],["write",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":13,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[],"const_generics":[],"trait_refs":[]}},"kind":{"TraitMethod":[10,"write"]}}]],"vtable":{"id":0,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"def_id":11,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":11}}],"span":{"span":{"file_id":19,"beg":{"line":1813,"col":12},"end":{"line":1813,"col":39}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":11,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[],"consts":[],"types":[],"type_clauses":[],"methods":[["eq",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":169,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[],"const_generics":[],"trait_refs":[]}},"kind":{"TraitMethod":[11,"eq"]}}]],"vtable":{"id":2,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"def_id":12,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["clone",0]},{"Ident":["impls",0]},{"Impl":{"Trait":12}}],"span":{"span":{"file_id":24,"beg":{"line":546,"col":16},"end":{"line":546,"col":33}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":12,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null],"consts":[],"types":[],"type_clauses":[],"methods":[["clone",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":178,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[],"const_generics":[],"trait_refs":[]}},"kind":{"TraitMethod":[12,"clone"]}}]],"vtable":null},{"def_id":13,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":13}}],"span":{"span":{"file_id":19,"beg":{"line":1928,"col":12},"end":{"line":1928,"col":34}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":13,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}},{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[{"kind":{"TraitImpl":{"id":14,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":11,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}},{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}}}}],"consts":[],"types":[],"type_clauses":[],"methods":[["partial_cmp",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":179,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[],"const_generics":[],"trait_refs":[]}},"kind":{"TraitMethod":[13,"partial_cmp"]}}]],"vtable":{"id":3,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}},{"def_id":14,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["cmp",0]},{"Ident":["impls",0]},{"Impl":{"Trait":14}}],"span":{"span":{"file_id":19,"beg":{"line":1813,"col":12},"end":{"line":1813,"col":39}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":11,"generics":{"regions":[],"types":[{"Literal":{"UInt":"Usize"}},{"Literal":{"UInt":"Usize"}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[],"consts":[],"types":[],"type_clauses":[],"methods":[["eq",{"params":{"regions":[{"index":0,"name":null},{"index":1,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":188,"generics":{"regions":[{"Var":{"Bound":[0,0]}},{"Var":{"Bound":[0,1]}}],"types":[],"const_generics":[],"trait_refs":[]}},"kind":{"TraitMethod":[11,"eq"]}}]],"vtable":{"id":4,"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"ordered_decls":[{"TraitDecl":{"NonRec":8}},{"Fun":{"NonRec":17}},{"Fun":{"NonRec":18}},{"TraitImpl":{"NonRec":6}},{"TraitDecl":{"NonRec":12}},{"Fun":{"NonRec":29}},{"Fun":{"NonRec":178}},{"TraitImpl":{"NonRec":12}},{"TraitDecl":{"NonRec":11}},{"Fun":{"NonRec":20}},{"TraitDecl":{"NonRec":5}},{"Type":{"NonRec":9}},{"Type":{"NonRec":3}},{"TraitDecl":{"NonRec":13}},{"TraitDecl":{"NonRec":15}},{"Fun":{"NonRec":50}},{"Fun":{"NonRec":31}},{"Fun":{"NonRec":169}},{"TraitImpl":{"NonRec":11}},{"Fun":{"NonRec":188}},{"TraitImpl":{"NonRec":14}},{"TraitImpl":{"NonRec":3}},{"Fun":{"NonRec":179}},{"TraitImpl":{"NonRec":13}},{"TraitDecl":{"NonRec":23}},{"Fun":{"NonRec":132}},{"TraitDecl":{"NonRec":10}},{"TraitDecl":{"NonRec":6}},{"Fun":{"NonRec":151}},{"Fun":{"NonRec":16}},{"Fun":{"NonRec":15}},{"TraitDecl":{"NonRec":7}},{"Fun":{"NonRec":11}},{"Fun":{"NonRec":192}},{"TraitImpl":{"NonRec":4}},{"TraitDecl":{"NonRec":16}},{"TraitDecl":{"NonRec":9}},{"Fun":{"NonRec":22}},{"Fun":{"NonRec":23}},{"Fun":{"NonRec":26}},{"Fun":{"NonRec":171}},{"Fun":{"NonRec":172}},{"Fun":{"NonRec":175}},{"TraitImpl":{"NonRec":9}},{"TraitDecl":{"NonRec":4}},{"Type":{"NonRec":4}},{"Fun":{"NonRec":40}},{"TraitImpl":{"NonRec":8}},{"TraitDecl":{"NonRec":27}},{"Fun":{"NonRec":190}},{"TraitDecl":{"NonRec":28}},{"Fun":{"NonRec":191}},{"TraitDecl":{"NonRec":2}},{"TraitDecl":{"NonRec":19}},{"Fun":{"NonRec":138}},{"Fun":{"NonRec":4}},{"Fun":{"NonRec":55}},{"TraitImpl":{"NonRec":7}},{"TraitDecl":{"NonRec":22}},{"Fun":{"NonRec":139}},{"TraitDecl":{"NonRec":24}},{"Fun":{"NonRec":143}},{"TraitDecl":{"NonRec":25}},{"Fun":{"NonRec":5}},{"TraitDecl":{"NonRec":26}},{"Type":{"NonRec":11}},{"TraitDecl":{"NonRec":18}},{"TraitDecl":{"NonRec":17}},{"Fun":{"NonRec":133}},{"Fun":{"NonRec":134}},{"TraitDecl":{"NonRec":30}},{"TraitDecl":{"NonRec":20}},{"Fun":{"NonRec":135}},{"Fun":{"NonRec":136}},{"Fun":{"NonRec":137}},{"TraitDecl":{"NonRec":21}},{"Type":{"NonRec":2}},{"Fun":{"NonRec":194}},{"TraitImpl":{"NonRec":2}},{"Fun":{"NonRec":168}},{"TraitImpl":{"NonRec":0}},{"Fun":{"NonRec":8}},{"Type":{"NonRec":0}},{"Type":{"NonRec":1}},{"Fun":{"NonRec":3}},{"Fun":{"NonRec":6}},{"Fun":{"NonRec":7}},{"Type":{"NonRec":5}},{"Fun":{"NonRec":12}},{"Fun":{"NonRec":13}},{"TraitImpl":{"NonRec":10}},{"Fun":{"NonRec":10}},{"TraitImpl":{"NonRec":5}},{"Fun":{"NonRec":0}},{"Fun":{"NonRec":1}},{"Fun":{"NonRec":2}}]}}